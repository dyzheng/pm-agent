"""Project lifecycle CLI: charter generation and project closure.

Usage:
    python -m tools.project_lifecycle charter projects/f-electron-scf
    python -m tools.project_lifecycle close projects/f-electron-scf
"""

from __future__ import annotations

import json
import sys
import time
from pathlib import Path

from tools.state_loader import load_state
from src.velocity import compute_velocity, forecast_completion


def _load_meta(project_dir: Path) -> dict:
    """Load project metadata from project_state_meta.json or project_state.json."""
    for candidate in [
        project_dir / "state" / "project_state_meta.json",
        project_dir / "state" / "project_state.json",
    ]:
        if candidate.exists():
            try:
                return json.loads(candidate.read_text())
            except (json.JSONDecodeError, OSError):
                pass
    pj = project_dir / "project.json"
    if pj.exists():
        return json.loads(pj.read_text())
    return {}


def generate_charter(project_dir: Path) -> Path:
    """Generate a charter.md template for a project.

    Pulls existing data from project state to pre-fill what's available,
    leaves placeholders for what needs human input.

    Returns path to generated charter file.
    """
    project_dir = Path(project_dir)
    meta = _load_meta(project_dir)
    md = meta.get("metadata", meta)

    # project.json has the canonical name
    pj_path = project_dir / "project.json"
    pj = json.loads(pj_path.read_text()) if pj_path.exists() else {}
    name = pj.get("name", meta.get("name", project_dir.name))
    request = meta.get("request", pj.get("request", ""))
    timeline = md.get("timeline", "[TODO: specify timeline]")
    milestones = md.get("milestones", {})
    keywords = meta.get("parsed_intent", {}).get("keywords", [])

    ms_text = ""
    if isinstance(milestones, dict) and milestones:
        for k, v in milestones.items():
            ms_text += f"- **{k}**: {v}\n"
    else:
        ms_text = "- [TODO: define milestones with gate conditions]\n"

    charter = f"""# Project Charter: {name}

**Created:** {time.strftime("%Y-%m-%d")}
**Project ID:** {project_dir.name}

## Goals

{request if request else "[TODO: describe project goals]"}

## Success Criteria

[TODO: define quantitative success criteria, e.g.:]
- [ ] Criterion 1: [metric] [target value]
- [ ] Criterion 2: [metric] [target value]
- [ ] Criterion 3: [metric] [target value]

## Scope

**In scope:**
{chr(10).join(f"- {kw}" for kw in keywords) if keywords else "- [TODO: list what is in scope]"}

**Out of scope:**
- [TODO: explicitly list what is NOT in scope]

## Constraints

- **Timeline:** {timeline}
- **Resources:** [TODO: team size, compute budget, etc.]
- **Dependencies:** [TODO: external dependencies]

## Milestones

{ms_text}
## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| [TODO] | High/Med/Low | High/Med/Low | [TODO] |

## Stakeholders

- [TODO: list stakeholders and their roles]

---
*This charter was auto-generated by pm-agent. Fill in [TODO] sections before project kickoff.*
"""

    out_path = project_dir / "charter.md"
    out_path.write_text(charter)
    print(f"  Generated: {out_path}")
    return out_path


def generate_closure(project_dir: Path) -> Path:
    """Generate a closure.md report from project state.

    Automatically computes metrics from task data and velocity.

    Returns path to generated closure file.
    """
    project_dir = Path(project_dir)
    state = load_state(project_dir)
    tasks = state["tasks"]
    meta = _load_meta(project_dir)
    md = meta.get("metadata", meta)

    name = state.get("name", project_dir.name)

    # Compute metrics
    total = len(tasks)
    done = [t for t in tasks if t.get("status") in ("done",)]
    terminated = [t for t in tasks if t.get("status") == "terminated"]
    deferred = [t for t in tasks if t.get("status") == "deferred"]
    failed = [t for t in tasks if t.get("status") == "failed"]
    pending = [t for t in tasks if t.get("status") in ("pending", "in_progress", "in_review")]

    vel = compute_velocity(tasks, window_weeks=4)

    # Delivered vs not delivered
    delivered = [f"- {t['id']}: {t.get('title', '')}" for t in done]
    not_delivered = [f"- {t['id']}: {t.get('title', '')} ({t.get('status', '')})" for t in pending + failed]
    deferred_list = [f"- {t['id']}: {t.get('title', '')} (trigger: {t.get('defer_trigger', 'N/A')})" for t in deferred]
    terminated_list = [f"- {t['id']}: {t.get('title', '')}" for t in terminated]

    closure = f"""# Project Closure Report: {name}

**Closed:** {time.strftime("%Y-%m-%d")}
**Project ID:** {project_dir.name}

## Summary

| Metric | Value |
|--------|-------|
| Total tasks | {total} |
| Completed | {len(done)} |
| Terminated | {len(terminated)} |
| Deferred | {len(deferred)} |
| Failed | {len(failed)} |
| Remaining | {len(pending)} |
| Completion rate | {round(len(done)/total*100, 1) if total else 0}% |
| Velocity (last 4 weeks) | {vel['tasks_per_week']} tasks/week |

## Delivered

{chr(10).join(delivered) if delivered else "- (none)"}

## Not Delivered

{chr(10).join(not_delivered) if not_delivered else "- (none â€” all tasks completed)"}

## Deferred (with triggers)

{chr(10).join(deferred_list) if deferred_list else "- (none)"}

## Terminated

{chr(10).join(terminated_list) if terminated_list else "- (none)"}

## Lessons Learned

[TODO: fill in after retrospective]

1. What went well?
2. What didn't go well?
3. What would we do differently?

## Recommendations for Follow-up

[TODO: any follow-up actions, successor projects, or technical debt to address]

---
*This closure report was auto-generated by pm-agent. Fill in [TODO] sections during retrospective.*
"""

    out_path = project_dir / "closure.md"
    out_path.write_text(closure)
    print(f"  Generated: {out_path}")

    # Also write structured JSON for programmatic use
    closure_data = {
        "closed_at": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
        "metrics": {
            "total_tasks": total,
            "completed": len(done),
            "terminated": len(terminated),
            "deferred": len(deferred),
            "failed": len(failed),
            "remaining": len(pending),
            "completion_rate": round(len(done) / total * 100, 1) if total else 0,
            "velocity_4w": vel["tasks_per_week"],
        },
        "delivered": [t["id"] for t in done],
        "not_delivered": [t["id"] for t in pending + failed],
        "deferred": [t["id"] for t in deferred],
        "terminated": [t["id"] for t in terminated],
    }
    json_path = project_dir / "closure.json"
    json_path.write_text(json.dumps(closure_data, indent=2, ensure_ascii=False))
    print(f"  Generated: {json_path}")

    return out_path


def main() -> None:
    args = sys.argv[1:]

    if len(args) < 2 or args[0] == "--help":
        print("Usage:")
        print("  python -m tools.project_lifecycle charter <project_dir>")
        print("  python -m tools.project_lifecycle close <project_dir>")
        sys.exit(0)

    command = args[0]
    project_dir = Path(args[1])

    if not project_dir.exists():
        print(f"Project directory not found: {project_dir}")
        sys.exit(1)

    if command == "charter":
        generate_charter(project_dir)
    elif command == "close":
        generate_closure(project_dir)
    else:
        print(f"Unknown command: {command}")
        print("Use 'charter' or 'close'")
        sys.exit(1)


if __name__ == "__main__":
    main()
