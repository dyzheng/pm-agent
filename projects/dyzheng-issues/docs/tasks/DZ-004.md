# DZ-004: 实现 nspin=2 时 init_chg=dm 功能

## Objective

GitHub Issue #6974。当前 `init_chg=dm`（从密度矩阵初始化电荷密度）不支持 nspin=2（自旋极化）情况。需要重构代码使其在 LCAO 基组下正确读取 spin-up/spin-down 两个分量的密度矩阵并初始化电荷密度。

## Reference Code

### Source Code (当前 init_chg=dm 实现)

**`/root/abacus-develop/source/source_esolver/esolver_ks_lcao.cpp`** (LCAO 入口)
- `ESolver_KS_LCAO::before_scf()`:163-209 — SCF 前初始化
- Line 170: `this->dmat.dm->init_DMR(*hamilt_lcao->getHR())` — 初始化 DMR 结构
- Lines 176-181: `init_chg="dm"` 分支
  - 读取文件: `{global_readin_dir}/dmrs1_nao.csr` (CSR 格式)
  - 调用: `LCAO_domain::init_dm_from_file<TK>()`
- Lines 205-209: `LCAO_domain::dm2rho()` — 密度矩阵→电荷密度转换

**`/root/abacus-develop/source/source_lcao/rho_tau_lcao.cpp`** (dm→rho 转换)
- `LCAO_domain::dm2rho()`:5-32
  ```cpp
  void dm2rho(std::vector<hamilt::HContainer<double>*> &dmr,
              const int nspin, Charge* chr, bool skip_normalize)
  ```
- 调用 `ModuleGint::cal_gint_rho(dmr, nspin, chr->rho)` 对每个 spin 分量积分

### Target Code (密度矩阵数据结构)

**`/root/abacus-develop/source/source_estate/module_dm/density_matrix.h`** (lines 280-299)
- `_DMR` vector: nspin=2 时 `_DMR.size()=2`，`_DMR[0]`=spin-up, `_DMR[1]`=spin-down
- `_DMK` vector: nspin=2 时 `_DMK.size()=2*nk`，索引 `_DMK[ik + _nk*(ispin-1)]`

**`/root/abacus-develop/source/source_estate/module_dm/density_matrix.cpp`**
- Line 71-73: `ik_begin = dm._nk * (is - 1)` — spin-down 的 k 点偏移
- Lines 546-619: `switch_dmr(mode)` — mode=0 原始, mode=1 总密度, mode=2 磁化密度

**`/root/abacus-develop/source/source_lcao/setup_dm.cpp`** (lines 16-20)
```cpp
const int nspin_dm = nspin == 2 ? 2 : 1;
this->dm = new elecstate::DensityMatrix<TK, double>(
    pv, nspin_dm, kv->kvec_d, kv->get_nks() / nspin_dm);
```

### PW 基组的 init_chg 参考

**`/root/abacus-develop/source/source_estate/module_charge/charge_init.cpp`** (lines 23-270)
- `Charge::init_rho()` — PW 基组的电荷初始化
- Line 30: 读取 `PARAM.inp.init_chg` 和 `PARAM.inp.nspin`
- nspin=2 时读取 `chgs1.cube` (spin-up) 和 `chgs2.cube` (spin-down)

### 文件 IO

**`/root/abacus-develop/source/source_lcao/module_hcontainer/read_hcontainer.cpp`**
- `ModuleIO::csrFileReader<T>` — CSR 格式读取器
- 密度矩阵文件: `dmrs1_nao.csr`

### 电荷密度归一化

**`/root/abacus-develop/source/source_estate/module_charge/charge.cpp`** (lines 217-238)
- `Charge::renormalize_rho()` — 对 `rho[0]` 和 `rho[1]` 分别归一化

## Implementation Guide

### Architecture Decisions

- nspin=2 时密度矩阵有两个分量 (`_DMR[0]`, `_DMR[1]`)，需要分别从文件读取
- 文件命名方案：`dmrs1_nao.csr` (spin-up) + `dmrs2_nao.csr` (spin-down)，与 PW 的 `chgs1.cube`/`chgs2.cube` 命名风格一致
- 或者：单个文件包含两个 spin 分量（需要检查当前 `init_dm_from_file` 的实现）

### Data Structure Mapping

| nspin | DMR 分量数 | DMK 大小 | 文件 | 电荷密度 |
|-------|-----------|---------|------|---------|
| 1 | 1 | nk | dmrs1_nao.csr | rho[0] |
| 2 | 2 | 2*nk | dmrs1_nao.csr + dmrs2_nao.csr | rho[0], rho[1] |
| 4 | 1 (complex) | nk | dmrs1_nao.csr | rho[0..3] |

### 实现步骤

1. 修改 `init_dm_from_file<TK>()` 支持 nspin=2：读取两个 CSR 文件分别填充 `_DMR[0]` 和 `_DMR[1]`
2. 确认 `dm2rho()` 已经正确处理 nspin=2（循环 nspin 次调用 `cal_gint_rho`）
3. 确认 `renormalize_rho()` 对两个 spin 分量都生效
4. 添加 nspin=2 的密度矩阵输出（SCF 收敛后写出两个 CSR 文件，供下次 restart 使用）

### Critical Implementation Details

- `init_dm_from_file` 当前可能只读取一个文件 — 需要扩展为 nspin=2 时读取两个
- 注意 k 点索引：nspin=2 时 `nks = 2*nk`，前 nk 个是 spin-up，后 nk 个是 spin-down
- `dm2rho` 中 `dmr[is]` 对应 `rho[is]`，这个映射在 nspin=2 时应该已经正确
- 需要同时检查密度矩阵**写出**逻辑，确保 nspin=2 时写出两个文件

## TDD Test Plan

### Tests to Write FIRST

```cpp
// test_init_dm_nspin2.cpp

TEST_F(InitDMTest, Nspin2_ReadTwoSpinComponents) {
    // 准备两个 CSR 文件: dmrs1_nao.csr (spin-up), dmrs2_nao.csr (spin-down)
    write_test_csr("dmrs1_nao.csr", dm_up_data);
    write_test_csr("dmrs2_nao.csr", dm_down_data);

    setup_nspin(2);
    init_dm_from_file<double>();

    // 验证两个 DMR 分量都被正确读取
    EXPECT_EQ(dmat._DMR.size(), 2);
    EXPECT_FALSE(is_zero(dmat._DMR[0]));  // spin-up 非零
    EXPECT_FALSE(is_zero(dmat._DMR[1]));  // spin-down 非零
}

TEST_F(InitDMTest, Nspin2_DM2Rho_TwoComponents) {
    // 从密度矩阵计算电荷密度
    setup_nspin(2);
    load_test_dm();
    dm2rho(dmr, 2, &chr);

    // rho[0] = spin-up, rho[1] = spin-down
    double total_up = integrate(chr.rho[0]);
    double total_down = integrate(chr.rho[1]);
    EXPECT_NEAR(total_up + total_down, nelec, 1e-6);
    EXPECT_GT(total_up, 0.0);
    EXPECT_GT(total_down, 0.0);
}

TEST_F(InitDMTest, Nspin1_Regression) {
    // nspin=1 回归测试 — 行为不变
    setup_nspin(1);
    init_dm_from_file<double>();
    EXPECT_EQ(dmat._DMR.size(), 1);
}
```

```python
# test_init_chg_dm_nspin2.py (集成测试)

def test_nspin2_init_chg_dm_reduces_scf_steps():
    """nspin=2 + init_chg=dm 应该比 init_chg=atomic 收敛更快"""
    # 先跑一次 SCF 获得收敛的密度矩阵
    result_atomic = run_abacus(nspin=2, init_chg="atomic")
    # 用密度矩阵重启
    result_dm = run_abacus(nspin=2, init_chg="dm")
    assert result_dm.scf_steps < result_atomic.scf_steps
```

## Acceptance Criteria

- [ ] nspin=2 时 init_chg=dm 正常工作
- [ ] 密度矩阵正确读取 spin-up 和 spin-down 分量
- [ ] SCF 从密度矩阵初始化后收敛步数明显减少
- [ ] LCAO 和 PW 基组均测试通过
- [ ] 添加回归测试
- [ ] 不影响 nspin=1/4 的现有行为
