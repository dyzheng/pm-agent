# DZ-002: 修复单精度 PW 计算 CUDA 运行时错误

## Objective

GitHub Issue #6768。ABACUS 3.10.1 中启用 `precision single` 进行 PW 基组计算时，出现 CUDA 运行时错误 `cudaErrorInvalidValue` (memory_op.cu:87)。需要定位并修复单精度模式下的 CUDA 内存操作错误。

## Reference Code

### Source Code (Bug 所在位置)

**`/root/abacus-develop/source/source_base/module_device/cuda/memory_op.cu`**
- Line 87 附近: `set_memory_2d_op` 模板特化，可能在单精度参数传递时类型不匹配
- Lines 233-354: 模板实例化区域
  - `resize_memory_op<float, DEVICE_GPU>` (line 234)
  - `resize_memory_op<std::complex<float>, DEVICE_GPU>` (line 236)
  - `cast_memory_op<float, double, ...>` (lines 283-302)

**`/root/abacus-develop/source/source_base/module_device/memory_op.h`** (类型别名)
- Lines 252-368: 单精度/双精度内存操作别名
  - `resmem_sh_op` = `resize_memory_op<float, DEVICE_CPU>`
  - `resmem_sd_op` = `resize_memory_op<float, DEVICE_GPU>`
  - `castmem_d2s_h2d_op` = `cast_memory_op<float, double, DEVICE_GPU, DEVICE_CPU>`

### Target Code (PW 精度处理)

**`/root/abacus-develop/source/source_basis/module_pw/pw_basis.h`** (lines 441-443)
```cpp
std::string precision = "double";
bool double_data_ = true;
bool float_data_ = false;
```

**`/root/abacus-develop/source/source_basis/module_pw/pw_basis.cpp`** (lines 16-20)
- 构造函数中根据 precision 设置 `double_data_` 和 `float_data_` 标志

**`/root/abacus-develop/source/source_basis/module_pw/pw_basis_k.cpp`**
- Lines 107-127: 根据 `float_data_` 分配 `s_gk2`, `s_gcar`, `s_kvec_c`
- Lines 301-340: GPU 内存分配和 double→float 类型转换

**`/root/abacus-develop/source/source_basis/module_pw/pw_basis_k.h`** (lines 104-105, 276-277)
- `float *s_gk2`, `float *s_gcar`, `float *s_kvec_c` — 单精度 GPU 数据
- `double *d_gk2`, `double *d_gcar`, `double *d_kvec_c` — 双精度 GPU 数据

### FFT 精度处理

**`/root/abacus-develop/source/source_base/module_fft/fft_bundle.cpp`** (lines 48-107)
- 根据 precision 创建 `FFT_CUDA<float>` 或 `FFT_CUDA<double>`
- "mixing" 模式同时创建两者

### 波函数精度处理

**`/root/abacus-develop/source/source_psi/setup_psi_pw.cpp`** (lines 31-48)
- 单精度时创建 `psi::Psi<T, Device>` (T=complex<float>)
- 同时保留双精度 `psi_d` 用于精度敏感操作

### GPU Transform 模板实例化

**`/root/abacus-develop/source/source_basis/module_pw/pw_transform_gpu.cpp`** (lines 110-144)
- `real2recip_gpu<float>`, `recip2real_gpu<float>` — 单精度 GPU FFT

**`/root/abacus-develop/source/source_basis/module_pw/kernels/cuda/pw_op.cu`** (lines 198-203)
- `set_3d_fft_box_op<float, DEVICE_GPU>` — 单精度 FFT box 操作

### 全局精度标志

**`/root/abacus-develop/source/source_io/module_parameter/read_set_globalv.cpp`** (lines 74-75)
- `sys.has_double_data` 和 `sys.has_float_data` 的设置逻辑

## Implementation Guide

### Architecture Decisions

- 排查重点：`set_memory_2d_op` 在单精度模式下的参数传递
- 可能原因：(1) pitch/width 参数类型不匹配；(2) cudaMemset2D 的 size 参数计算错误（sizeof(float) vs sizeof(double)）；(3) 某个模块未正确实例化 float 模板
- 调试方法：在 memory_op.cu:87 前添加参数打印，确认传入的 width/height/pitch 值

### 排查路径

1. 确认 `set_memory_2d_op<float>` 的调用链 — 哪个模块触发了 line 87
2. 检查 `cudaMallocPitch` / `cudaMemset2D` 的参数是否正确使用 `sizeof(float)`
3. 检查 PW_Basis_K 中 `s_gk2` 等数组的分配大小是否正确
4. 检查 FFT_CUDA<float> 的初始化是否完整

### Critical Implementation Details

- `cudaErrorInvalidValue` 通常表示传入 CUDA API 的参数超出合法范围
- 单精度模式下 `sizeof(std::complex<float>)=8` vs `sizeof(std::complex<double>)=16`
- 如果某处用 `sizeof(double)` 计算了 pitch 但实际数据是 float，会导致越界
- "mixing" 精度模式可作为对照测试（同时分配 float 和 double）

## TDD Test Plan

### Tests to Write FIRST

```cpp
// test_memory_op_single_precision.cu

TEST(MemoryOpTest, ResizeMemoryFloat_GPU) {
    float* ptr = nullptr;
    resize_memory_op<float, DEVICE_GPU>()(ptr, 1024);
    ASSERT_NE(ptr, nullptr);
    delete_memory_op<float, DEVICE_GPU>()(ptr);
}

TEST(MemoryOpTest, ResizeMemoryComplexFloat_GPU) {
    std::complex<float>* ptr = nullptr;
    resize_memory_op<std::complex<float>, DEVICE_GPU>()(ptr, 1024);
    ASSERT_NE(ptr, nullptr);
    delete_memory_op<std::complex<float>, DEVICE_GPU>()(ptr);
}

TEST(MemoryOpTest, SetMemory2D_Float_GPU) {
    // 重点测试 set_memory_2d_op<float> — 这是 line 87 的位置
    float* ptr = nullptr;
    int pitch = 0;
    set_memory_2d_op<float, DEVICE_GPU>()(ptr, pitch, 128, 64);
    ASSERT_NE(ptr, nullptr);
    EXPECT_GE(pitch, 128 * sizeof(float));
    delete_memory_op<float, DEVICE_GPU>()(ptr);
}

TEST(MemoryOpTest, CastMemoryDoubleToFloat_GPU) {
    // double→float 转换
    double h_src[4] = {1.0, 2.0, 3.0, 4.0};
    float* d_dst = nullptr;
    double* d_src = nullptr;
    resize_memory_op<float, DEVICE_GPU>()(d_dst, 4);
    resize_memory_op<double, DEVICE_GPU>()(d_src, 4);
    synchronize_memory_op<double, DEVICE_GPU, DEVICE_CPU>()(d_src, h_src, 4);
    cast_memory_op<float, double, DEVICE_GPU, DEVICE_GPU>()(d_dst, d_src, 4);
    // verify
    float h_dst[4];
    synchronize_memory_op<float, DEVICE_CPU, DEVICE_GPU>()(h_dst, d_dst, 4);
    EXPECT_NEAR(h_dst[0], 1.0f, 1e-6f);
}
```

## Acceptance Criteria

- [ ] si16_pw 示例在 precision=single 模式下正常运行完成
- [ ] CUDA 和 CPU 两种后端均测试通过
- [ ] 添加单精度 PW 的回归测试
- [ ] 不影响双精度计算结果
