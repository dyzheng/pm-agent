# DZ-007: 单精度 PW 全面测试与加固

## Objective

在 DZ-002 修复 CUDA 错误后，对单精度 PW 计算进行全面测试加固。覆盖 CPU/GPU 两种后端、nspin=1/2 各种自旋模式，验证单精度与双精度结果的数值偏差在可接受范围内，并添加 CI 回归测试。

## Reference Code

### Source Code (精度控制流程)

**`/root/abacus-develop/source/source_io/module_parameter/read_set_globalv.cpp`** (lines 74-75)
- `sys.has_double_data` 和 `sys.has_float_data` 的设置逻辑
- `precision="single"` → `has_float_data=true, has_double_data=false`
- `precision="mixing"` → 两者都为 true

**`/root/abacus-develop/source/source_io/module_parameter/system_parameter.h`** (lines 64-65)
```cpp
bool has_double_data = true;
bool has_float_data = false;
```

### PW 基组精度处理

**`/root/abacus-develop/source/source_basis/module_pw/pw_basis.h`** (lines 441-443)
```cpp
std::string precision = "double";
bool double_data_ = true;
bool float_data_ = false;
```

**`/root/abacus-develop/source/source_basis/module_pw/pw_basis.cpp`** (lines 16-20)
- 构造函数根据 precision 设置标志

**`/root/abacus-develop/source/source_basis/module_pw/pw_basis_k.h`** (lines 104-105, 276-277)
- 单精度数据: `float *s_gk2`, `float *s_gcar`, `float *s_kvec_c`
- 双精度数据: `double *d_gk2`, `double *d_gcar`, `double *d_kvec_c`

**`/root/abacus-develop/source/source_basis/module_pw/pw_basis_k.cpp`** (lines 107-127, 301-340)
- 根据 `float_data_` 分配 GPU 内存并执行 double→float 转换

### FFT 精度

**`/root/abacus-develop/source/source_base/module_fft/fft_bundle.cpp`** (lines 48-107)
- `FFT_CUDA<float>` / `FFT_CUDA<double>` 按需创建

### 波函数精度

**`/root/abacus-develop/source/source_psi/setup_psi_pw.cpp`** (lines 31-48)
- 单精度: `psi::Psi<complex<float>, Device>`
- 同时保留双精度 `psi_d` 用于精度敏感操作

### GPU Transform

**`/root/abacus-develop/source/source_basis/module_pw/pw_transform_gpu.cpp`** (lines 110-144)
- `real2recip_gpu<float>`, `recip2real_gpu<float>` 模板实例化

**`/root/abacus-develop/source/source_basis/module_pw/pw_transform_k.cpp`** (lines 537-603)
- `real2recip<float>`, `recip2real<float>` CPU 模板实例化

### GPU Kernel

**`/root/abacus-develop/source/source_basis/module_pw/kernels/cuda/pw_op.cu`** (lines 198-203)
- `set_3d_fft_box_op<float, DEVICE_GPU>` 等 GPU kernel 实例化

### 现有测试

**`/root/abacus-develop/tests/`** — 集成测试目录
- 需要检查是否已有 `precision=single` 的测试用例

## Implementation Guide

### Architecture Decisions

- 测试矩阵覆盖: precision × nspin × backend = {single,double,mixing} × {1,2} × {cpu,gpu}
- 数值偏差标准: 单精度 vs 双精度能量偏差 < 1e-4 Ry（float 精度约 7 位有效数字）
- 优先使用已有的 si16_pw 示例作为基准测试

### 测试矩阵

| 测试编号 | precision | nspin | backend | 验证内容 |
|---------|-----------|-------|---------|---------|
| T1 | single | 1 | CPU | 基本功能 |
| T2 | single | 1 | GPU | GPU 单精度 (DZ-002 修复验证) |
| T3 | single | 2 | CPU | 自旋极化单精度 |
| T4 | single | 2 | GPU | 自旋极化 GPU 单精度 |
| T5 | mixing | 1 | GPU | 混合精度 |
| T6 | double | 1 | CPU | 双精度基准 (回归) |
| T7 | double | 1 | GPU | GPU 双精度基准 (回归) |

### 数值偏差验证方法

1. 以 `precision=double` 结果为参考
2. 比较总能量: `|E_single - E_double| < 1e-4 Ry`
3. 比较力: `|F_single - F_double| < 1e-3 Ry/Bohr`
4. 比较应力: `|σ_single - σ_double| < 1e-3 kbar`
5. 比较电荷密度: `max|ρ_single - ρ_double| / max|ρ_double| < 1e-3`

### Critical Implementation Details

- 单精度 FFT 的精度损失主要来自大数相消（如动能项）
- `mixing` 模式在关键步骤用双精度，FFT 用单精度，是精度/性能的折中
- nspin=2 时需要验证 spin-up 和 spin-down 分别的精度
- GPU 和 CPU 的单精度结果可能因浮点运算顺序不同而有微小差异

## TDD Test Plan

### Tests to Write FIRST

```python
# test_single_precision_pw.py

import pytest
import subprocess
import json

TOLERANCE_ENERGY = 1e-4  # Ry
TOLERANCE_FORCE = 1e-3   # Ry/Bohr

@pytest.fixture
def si16_double_reference():
    """Run si16_pw with double precision as reference."""
    return run_abacus("examples/si16_pw", precision="double")

@pytest.mark.parametrize("backend", ["cpu", "gpu"])
def test_single_precision_nspin1(si16_double_reference, backend):
    """Single precision PW nspin=1 on CPU and GPU."""
    result = run_abacus("examples/si16_pw", precision="single", device=backend)
    assert result.converged
    assert abs(result.energy - si16_double_reference.energy) < TOLERANCE_ENERGY

@pytest.mark.parametrize("backend", ["cpu", "gpu"])
def test_single_precision_nspin2(backend):
    """Single precision PW nspin=2 (spin-polarized)."""
    ref = run_abacus("examples/Fe_pw", precision="double", nspin=2)
    result = run_abacus("examples/Fe_pw", precision="single", nspin=2, device=backend)
    assert result.converged
    assert abs(result.energy - ref.energy) < TOLERANCE_ENERGY
    assert abs(result.total_mag - ref.total_mag) < 0.01  # uB

def test_mixing_precision():
    """Mixing precision should be between single and double accuracy."""
    ref_double = run_abacus("examples/si16_pw", precision="double")
    ref_single = run_abacus("examples/si16_pw", precision="single")
    ref_mixing = run_abacus("examples/si16_pw", precision="mixing")
    # mixing 精度应优于 single
    err_single = abs(ref_single.energy - ref_double.energy)
    err_mixing = abs(ref_mixing.energy - ref_double.energy)
    assert err_mixing <= err_single
```

## Acceptance Criteria

- [ ] 单精度 PW 在 CPU 和 GPU 后端均通过标准测试集
- [ ] 单精度 vs 双精度能量偏差 < 1e-4 Ry
- [ ] nspin=1/2 均测试通过
- [ ] CI 中添加单精度 PW 测试用例
