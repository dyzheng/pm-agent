# DZ-006: 优化 SOC 开启时的内存占用

## Objective

GitHub Issue #6377。用户报告开启自旋轨道耦合（SOC, nspin=4）后内存占用显著增大。需要分析内存热点，识别优化机会，在不影响计算结果的前提下降低峰值内存。

## Reference Code

### Source Code (内存热点分析)

**1. 密度矩阵 DMK — 最大内存消耗**

**`/root/abacus-develop/source/source_estate/module_dm/density_matrix.cpp`** (lines 30-41)
- `_DMK.resize(nks); _DMK[ik].resize(nrow * ncol)`
- 内存: `nk × (nlocal×npol) × (nlocal×npol) × 16 bytes`，npol=2 时 **4x 增长**
- 类型: `std::vector<std::vector<std::complex<double>>>`

**`/root/abacus-develop/source/source_estate/module_dm/density_matrix.h`** (lines 68-332)
- `_DMR` vector: nspin=4 时 `_DMR.size()=1` 但元素为 `std::complex<double>` (16 bytes vs 8 bytes)
- `_DMK` vector: nspin=4 时 `_DMK.size()=nk`，每个元素 `(nlocal*2)^2 * 16 bytes`

**2. Hamiltonian/Overlap 矩阵 HR/SR**

**`/root/abacus-develop/source/source_lcao/hamilt_lcao.cpp`** (lines 60-92)
- nspin==4 时模板实例化为 `HamiltLCAO<complex<double>, complex<double>>`
- `hR = new HContainer<std::complex<double>>(paraV)` — **2x 增长** (complex vs real)
- `sR = new HContainer<std::complex<double>>(paraV)` — **2x 增长**

**3. HContainer 核心内存分配**

**`/root/abacus-develop/source/source_lcao/module_hcontainer/hcontainer.cpp`** (lines 190-231)
- `allocated_size = nnr * sizeof(T)`
- nspin==4: `sizeof(T) = 16` (complex<double>)
- nspin<4: `sizeof(T) = 8` (double)

**4. SOC 稀疏矩阵**

**`/root/abacus-develop/source/source_lcao/LCAO_HS_arrays.hpp`** (lines 47-63)
- `HR_soc_sparse`: `map<Vector3, map<size_t, map<size_t, complex<double>>>>`
- `SR_soc_sparse`: 同上
- `dHRx/y/z_soc_sparse`: 力/应力导数（3 个额外稀疏矩阵）
- 三层嵌套 map 的内存开销显著（每个 entry ~100+ bytes overhead）

**5. 临时缓冲区**

**`/root/abacus-develop/source/source_estate/module_dm/density_matrix.cpp`** (lines 123, 281)
- `std::vector<TK> tmp_DMR((nspin==4) ? mat_size*R_size : 0)` — 仅 nspin=4 分配

**6. DFT+U SOC 临时数组**

**`/root/abacus-develop/source/source_lcao/spar_u.cpp`** (lines 160-161)
- `new complex<double>[pv.nloc]` × 2 — 每个 R 坐标分配一次

**7. Spinor 系数**

**`/root/abacus-develop/source/source_pw/module_pwdft/soc.h`** (lines 7-41)
- `Fcoef`: 5D 数组，硬编码 `ind2=2, ind3=2` 用于 spinor 块
- `p_rot`: 旋转矩阵 `complex<double>[l2plus1 * l2plus1]`

### Target Code (并行初始化)

**`/root/abacus-develop/source/source_lcao/LCAO_init_basis.cpp`** (lines 22-39)
- nspin==4 时 `nb2d = 2`（最小块大小），确保 2×2 spinor 块

## Implementation Guide

### Architecture Decisions

- 优化策略应按内存占比排序：DMK > HR/SR > SOC sparse > 临时缓冲
- 不改变数值结果，所有优化必须是内存布局/分配策略层面的
- 优先考虑低风险优化（延迟分配、及时释放），再考虑高风险优化（稀疏存储、压缩）

### 内存占比估算 (100 原子, 1000 基函数, 10 k 点)

| 数据结构 | nspin=2 内存 | nspin=4 内存 | 增长倍数 |
|----------|-------------|-------------|---------|
| DMK | 10×1000²×8 = 80 MB | 10×2000²×16 = 640 MB | **8x** |
| HR | nnr×8 | nnr×16 | 2x |
| SR | nnr×8 | nnr×16 | 2x |
| SOC sparse | 0 | ~50-200 MB (取决于稀疏度) | ∞ |
| tmp_DMR | 0 | ~mat_size×R_size×16 | ∞ |

### 优化方案

**方案 1（低风险）: DMK 延迟分配 + 及时释放**
- 不需要同时持有所有 k 点的 DMK
- 按需分配当前 k 点的 DMK，用完释放
- 预期收益：DMK 内存从 `nk × size` 降为 `1 × size`

**方案 2（中风险）: SOC 稀疏矩阵改用 CSR 格式**
- 当前三层嵌套 map 内存开销大
- 改用 CSR (Compressed Sparse Row) 可减少 ~50% 内存
- 需要修改所有访问 `HR_soc_sparse` 的代码

**方案 3（中风险）: HR/SR 利用 Hermitian 对称性**
- Hamiltonian 是 Hermitian 的：`H[i,j] = conj(H[j,i])`
- 只存储上三角，内存减半
- 需要修改所有矩阵访问逻辑

**方案 4（低风险）: 临时缓冲区复用**
- `spar_u.cpp` 中每个 R 坐标都 new/delete 临时数组
- 改为预分配一次，循环复用

### Critical Implementation Details

- DMK 是 SCF 迭代中频繁访问的数据，延迟分配需要仔细设计生命周期
- SOC sparse 矩阵在力/应力计算中使用，修改格式需要同步修改 `dHRx/y/z_soc_sparse`
- Hermitian 优化需要确保所有读取代码都能处理只有上三角的情况
- 任何优化都必须通过 SOC 回归测试（099_PW_DJ_SO 等）

## TDD Test Plan

### Tests to Write FIRST

```cpp
// test_soc_memory.cpp

TEST_F(SOCMemoryTest, DMK_PeakMemory_Reduced) {
    // 测量 SOC 模式下 DMK 的峰值内存
    setup_soc_system(natom=50, nk=10);
    size_t peak_before = measure_peak_memory();
    run_scf_with_optimization();
    size_t peak_after = measure_peak_memory();
    // 优化后峰值内存应降低
    EXPECT_LT(peak_after, peak_before * 0.8);
}

TEST_F(SOCMemoryTest, NumericalConsistency) {
    // 优化前后计算结果一致
    setup_soc_system(natom=10, nk=4);
    auto result_before = run_scf_original();
    auto result_after = run_scf_optimized();
    EXPECT_NEAR(result_before.energy, result_after.energy, 1e-12);
    for (int i = 0; i < 3; i++) {
        EXPECT_NEAR(result_before.force[i], result_after.force[i], 1e-10);
    }
}

TEST_F(SOCMemoryTest, SparseMatrixCSR_Equivalent) {
    // CSR 格式与 map 格式结果一致
    auto hr_map = build_hr_soc_sparse_map();
    auto hr_csr = build_hr_soc_sparse_csr();
    for (auto& [R, mat] : hr_map) {
        for (auto& [i, row] : mat) {
            for (auto& [j, val] : row) {
                EXPECT_NEAR(std::abs(val - hr_csr.get(R, i, j)), 0.0, 1e-15);
            }
        }
    }
}
```

## Acceptance Criteria

- [ ] 分析并记录 SOC 模式下各模块的内存占用分布
- [ ] 识别至少一个可优化的内存热点
- [ ] 实现优化后内存降低 ≥20%（或证明当前已是最优）
- [ ] SOC 计算结果不变（数值一致性验证）
- [ ] 在 issue 中回复分析结果
