# FE-205-2: 惩罚势计算与占据数投影

## Objective

[工程追赶] 实现惩罚势核心算法：
(1) 从 DFT+U 的 onsite projector 获取 f 轨道占据矩阵，计算 n_f = Tr(occupation_matrix) 得到 f 电子数
(2) 实现二次惩罚势 V_penalty = λ·(n_f - n_target)²，计算对应的势能贡献和力贡献 dV/dn = 2λ·(n_f - n_target)
(3) 将惩罚势叠加到 Hamiltonian（复用 DFT+U 的 V_eff 接口）
(4) 单元测试：给定已知占据矩阵，验证惩罚势数值正确

## Reference Code

### Target Code (develop 分支)

**`/root/abacus-develop/source/source_lcao/module_dftu/dftu.h`** (354 lines)
- `Plus_U::locale[iat][l][n][spin]` — 占据矩阵，n_f = Tr(locale[iat][l=3])
- `Plus_U::eff_pot_pw` — V_U 势数组，惩罚势叠加到此
- `Plus_U::cal_VU_pot_pw(spin)` — 计算 V_U，可参考其势构建逻辑

**`/root/abacus-develop/source/source_pw/module_pwdft/onsite_proj_tools.cpp`** (1020 lines)
- `cal_force_dftu()`:806 — 力计算，惩罚势的力贡献可类似实现

**FE-205-1 产出**: `charge_constraint.h/cpp` — ChargeConstraint 类骨架

### Prior Art

**DFT+U 的 V_U 势构建**: `Plus_U::cal_VU_pot_pw()` 从 locale 构建 vu_iat 矩阵，惩罚势的构建方式类似但更简单（标量 × 单位矩阵）。

## Implementation Guide

### Architecture Decisions

- **n_f 提取**: 从 `Plus_U::locale[iat][l=3]` 提取，n_f = Σ_m locale[m,m].real()（对角元素之和）
- **势叠加方式**: dV/dn_f 是标量，乘以 f 轨道的单位投影算符后叠加到 eff_pot_pw
- **复用 DFT+U 路径**: 惩罚势通过修改 eff_pot_pw 实现，不需要新的算符

### 惩罚势公式

```
n_f = Tr(locale[iat][l=3]) = Σ_{m=-3}^{3} locale[m,m].real()

E_penalty = Σ_iat λ_iat · (n_f_iat - n_target_iat)²

dV/dn_f = 2 · λ · (n_f - n_target)

势叠加到 eff_pot_pw:
  vu_iat[m,m'] += dV/dn_f · δ_{m,m'}  (对角叠加)
  即: vu_iat 的对角元素各加 dV/dn_f
```

### Critical Implementation Details

- **nspin 处理**: nspin=4 时 locale 有 4 个自旋分量，n_f = locale[0,0] + locale[3,3]（charge 分量）
- **nspin=2 时**: n_f = locale[spin=0] + locale[spin=1] 的对角元素之和
- **势叠加时机**: 在 `cal_VU_pot_pw()` 之后调用 `add_penalty_potential()`
- **能量贡献**: E_penalty 需要加到总能量中，在 `cal_energy()` 中输出
- **力贡献**: 惩罚势对力的贡献通过 eff_pot_pw 的修改自动包含在 DFT+U 力计算中

## TDD Test Plan

### Tests to Write FIRST

```cpp
TEST_F(PenaltyPotTest, ComputeNf) {
    // 从已知 locale 计算 n_f
    set_locale_diagonal(iat_Ce, l_f, {0.2, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1});
    double n_f = compute_nf(iat_Ce);
    EXPECT_NEAR(n_f, 0.8, 1e-10);  // sum of diagonal
}

TEST_F(PenaltyPotTest, PenaltyEnergy) {
    // V = λ·(n_f - n_target)²
    double lambda = 10.0, n_f = 1.5, n_target = 1.0;
    double E = compute_penalty_energy(lambda, n_f, n_target);
    EXPECT_NEAR(E, 2.5, 1e-10);
}

TEST_F(PenaltyPotTest, PenaltyPotential) {
    // dV/dn = 2λ·(n_f - n_target)
    double lambda = 10.0, n_f = 1.5, n_target = 1.0;
    double dV = compute_penalty_potential(lambda, n_f, n_target);
    EXPECT_NEAR(dV, 10.0, 1e-10);
}

TEST_F(PenaltyPotTest, PotentialAddedToEffPot) {
    // 惩罚势应叠加到 eff_pot_pw 的对角元素
    auto eff_pot_before = get_eff_pot_pw(iat_Ce);
    add_penalty_potential(iat_Ce, /*dV=*/5.0);
    auto eff_pot_after = get_eff_pot_pw(iat_Ce);
    for (int m = 0; m < 7; m++) {
        int diag_idx = m * 7 + m;  // 对角元素
        EXPECT_NEAR(eff_pot_after[diag_idx].real() - eff_pot_before[diag_idx].real(), 5.0, 1e-10);
    }
}
```

## Acceptance Criteria

- [ ] 惩罚势 V = λ·(n_f - n_target)² 计算正确
- [ ] 势能贡献正确叠加到 Hamiltonian
- [ ] 与 DFT+U projector 接口对接
- [ ] 数值单元测试通过
