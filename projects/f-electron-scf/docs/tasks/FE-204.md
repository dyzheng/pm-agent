# FE-204: 能量监控 + SCF 自动回退机制

## Objective

在 SCF 主循环中实现：(1) 逐步监控总能量变化，检测震荡模式，(2) 当能量连续上升 N 步时，自动减小 mixing_beta 并回退到上一个低能量状态，(3) 当检测到周期性震荡时，切换 mixing 策略（如从 Broyden 切换到 Pulay 或 plain），(4) 输出诊断信息帮助用户理解收敛行为。

## Reference Code

### Target Code (develop 分支)

**`/root/abacus-develop/source/source_esolver/esolver_ks_pw.cpp`** (447 lines)
- `iter_init()`:190 — SCF 迭代开始
- `iter_finish()` — SCF 迭代结束，检查收敛
- 需添加能量历史记录和震荡检测

**`/root/abacus-develop/source/source_estate/module_charge/charge_mixing.cpp`** (259 lines)
- `Charge_Mixing::set_mixing()` — mixing 参数设置
- `Charge_Mixing::mix_reset()` — mixing 重置（清空 Broyden 历史）

**`/root/abacus-develop/source/source_estate/module_charge/charge_mixing_rho.cpp`** (613 lines)
- `mix_rho()` — 实际执行 mixing

**`/root/abacus-develop/source/source_estate/module_charge/chgmixing.cpp`** (120-172)
- `chgmixing_ks_pw()` — mixing 协调点，mixing_restart 逻辑

### Prior Art

**FE-112** — SCF 震荡检测（更基础的版本），FE-204 在此基础上增加状态回退和策略切换。
**VASP**: 能量上升时自动减小 AMIX。
**QE**: `adaptive_thr` 在 `electrons.f90` 中根据收敛情况调整 diag threshold。

## Implementation Guide

### Architecture Decisions

- **SCF Monitor 类**: 新建 `SCFMonitor` 类封装能量监控、震荡检测、回退逻辑
- **状态快照**: 保存上一个"好"状态（电荷密度 + 波函数），用于回退
- **策略切换**: 震荡时从 Broyden → plain mixing，稳定后切回 Broyden
- **与 FE-112 的关系**: FE-112 是简单的震荡检测+参数调整，FE-204 增加了状态回退和策略切换

### 回退机制

```
SCFMonitor::check_and_act(iter, energy):
  energy_history.push(energy)

  if is_diverging(window=3):
    # 能量连续上升 3 步
    restore_checkpoint()           # 回退到上一个低能量状态
    mixing_beta *= 0.5             # 减小 mixing
    mix_reset()                    # 清空 Broyden 历史
    log("Energy diverging, rollback + reduce mixing_beta")

  elif is_oscillating(window=5):
    # 能量交替震荡 5 步
    switch_to_plain_mixing()       # 切换到 plain mixing
    mixing_beta *= 0.3             # 大幅减小 mixing
    log("Energy oscillating, switch to plain mixing")

  elif is_converging_well():
    # 收敛良好，可以加速
    if using_plain_mixing:
      switch_to_broyden()          # 切回 Broyden
    mixing_beta = min(mixing_beta * 1.1, initial_beta)  # 逐步恢复
```

### 状态快照设计

| 保存内容 | 大小 | 说明 |
|----------|------|------|
| `rho` (电荷密度) | nrxx × nspin | 实空间电荷密度 |
| `rho_save` (上一步) | nrxx × nspin | 用于 mixing |
| `locale` (占据矩阵) | nat × (2l+1)² × nspin | DFT+U 占据矩阵 |
| `energy` | 1 double | 总能量 |
| 不保存波函数 | — | 内存开销太大，回退后重新 diag |

### Critical Implementation Details

- **内存开销**: 只保存电荷密度和占据矩阵，不保存波函数（太大）
- **回退后重新 diag**: 回退电荷密度后需要重新对角化得到波函数
- **mixing_beta 下限**: 0.01，防止收敛过慢
- **策略切换次数限制**: 最多切换 3 次，避免无限循环
- **与 U-ramping 的交互**: U-ramping 更新时不触发回退（U 变化导致的能量变化是正常的）
- **诊断输出**: 每步输出 energy, drho, mixing_beta, 检测状态

## TDD Test Plan

### Tests to Write FIRST

```cpp
TEST_F(SCFMonitorTest, DetectDivergence) {
    SCFMonitor monitor;
    monitor.add(-100.0);
    monitor.add(-99.5);
    monitor.add(-99.0);
    monitor.add(-98.5);
    EXPECT_TRUE(monitor.is_diverging());
}

TEST_F(SCFMonitorTest, RollbackReducesBeta) {
    SCFMonitor monitor;
    double beta = 0.7;
    simulate_diverging_scf(monitor, 3);
    monitor.apply_action(beta, charge_mixing);
    EXPECT_LT(beta, 0.7);
}

TEST_F(SCFMonitorTest, NormalConvergenceNoAction) {
    SCFMonitor monitor;
    for (double e : {-100.0, -100.5, -100.8, -100.9}) monitor.add(e);
    EXPECT_FALSE(monitor.is_diverging());
    EXPECT_FALSE(monitor.is_oscillating());
}

TEST_F(SCFMonitorTest, CheckpointRestore) {
    save_checkpoint(rho, locale, energy);
    modify_rho();  // 模拟 SCF 步进
    restore_checkpoint(rho, locale, energy);
    EXPECT_NEAR(energy, original_energy, 1e-10);
}
```

## Acceptance Criteria

- [ ] 原本不收敛的 f 电子体系中 >70% 可通过自动回退收敛
- [ ] 监控 SCF 能量变化趋势
- [ ] 能量上升时自动减小 mixing_beta
- [ ] 回退到上一步收敛的电荷密度
- [ ] 诊断输出清晰有用
