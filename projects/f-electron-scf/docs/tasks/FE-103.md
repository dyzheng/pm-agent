# FE-103: DFT+U PW force

## Objective

PW 基组下 DFT+U 力的计算。适配 forces_onsite.cpp 到 Plus_U 接口，确保 cal_force_dftu() 在 Onsite_Proj_tools 中正确工作。

## Reference Code

### Source Code (zdy-tmp 参考实现)

**`/root/abacus-zdy-tmp/source/source_pw/module_pwdft/onsite_proj_tools.cpp`**
- `cal_force_dftu(ik, npm, force, orbital_corr, vu, size_vu, h_wg)` — DFT+U 力计算核心
  - 使用 `dbecp_f`（becp 对原子位移的导数）
  - 力 = -2 Re[ Σ_ib wg(ib) * Σ_m,m' vu(m,m') * dbecp*(ib,m) * becp(ib,m') ]
  - 需要先调用 `cal_dbecp_f(ik, npm, ipol)` 计算 d<β|ψ>/dτ

**`/root/abacus-zdy-tmp/source/source_pw/module_pwdft/forces_onsite.cpp`** (81 lines)
- `cal_force_onsite()` — 调用入口
  - 循环 k-points → 调用 `onsite_p->get_fs_tools()->cal_force_dftu()`
  - 传递 `Plus_U::eff_pot_pw` 作为 vu 参数
  - 传递 `Plus_U::orbital_corr` 作为轨道角动量信息

### Target Code (develop 分支)

**`/root/abacus-develop/source/source_pw/module_pwdft/onsite_proj_tools.cpp`** (1020 lines)
- `cal_force_dftu()`:806 — 已有函数签名，需验证实现完整性
- `cal_dbecp_f(ik, npm, ipol)` — becp 对原子位移的导数

**`/root/abacus-develop/source/source_pw/module_pwdft/forces_onsite.cpp`** (81 lines)
- `cal_force_onsite()` — 需确保正确调用 cal_force_dftu 并传递 Plus_U 数据

**`/root/abacus-develop/source/source_esolver/esolver_ks_pw.cpp`** (447 lines)
- `cal_force()` — ESolver 力计算入口，需确保调用 onsite force

### Prior Art

**`/root/abacus-develop/source/source_lcao/module_dftu/dftu_force.cpp`** (579 lines)
- LCAO 版本的 DFT+U 力计算（`cal_force_k()`, `cal_force_gamma()`）
- 物理公式相同，但使用 LCAO 基组的 overlap 矩阵

## Implementation Guide

### Architecture Decisions

- PW 力通过 `Onsite_Proj_tools::cal_force_dftu()` 计算，与 LCAO 路径完全独立
- 力的计算需要 becp 和 dbecp_f（对 3 个笛卡尔方向的导数）
- `forces_onsite.cpp` 是统一入口，同时处理 DFT+U 和 DeltaSpin 力

### Data Structure Mapping

| 量 | 变量 | 说明 |
|----|------|------|
| V_U 势 | `Plus_U::eff_pot_pw` | complex 数组，按 iat 索引 |
| 轨道角动量 | `Plus_U::orbital_corr` | int 数组，每个原子类型的 l 值 |
| becp | `Onsite_Proj_tools::becp` | ⟨β\|ψ⟩ 投影系数 |
| dbecp_f | `Onsite_Proj_tools::dbecp` | d⟨β\|ψ⟩/dτ_ipol |
| 力 | `force[iat][ipol]` | 输出，3N 分量 |
| 权重 | `h_wg[ib]` | wg(ik,ib) 带权重 |

### Critical Implementation Details

- **力的公式**: F_U(iat,ipol) = -2 Re[ Σ_k Σ_ib wg * Σ_m,m' V_U(m,m') * d⟨β_m|ψ_ib⟩/dτ_ipol * ⟨β_m'|ψ_ib⟩ ]
- **3 个方向**: ipol = 0,1,2 分别对应 x,y,z，每个方向需单独调用 `cal_dbecp_f`
- **MPI 归约**: 力需要跨 k-point pool 归约
- **对称性**: 力应满足 Newton 第三定律（总力为零），可作为验证条件

## TDD Test Plan

### Tests to Write FIRST

```cpp
TEST_F(DftuPwForceTest, ForceSymmetry) {
    // CeO2: 力的总和应为零（Newton 第三定律）
    run_dftu_pw_scf("CeO2_nspin4");
    auto force = cal_force();
    double total_force[3] = {0, 0, 0};
    for (int iat = 0; iat < nat; iat++)
        for (int i = 0; i < 3; i++)
            total_force[i] += force[iat][i];
    for (int i = 0; i < 3; i++)
        EXPECT_NEAR(total_force[i], 0.0, 1e-8);
}

TEST_F(DftuPwForceTest, ForceVsLCAO) {
    // PW 力与 LCAO 力应一致（相同体系、相同 U 值）
    auto force_pw = run_pw_force("CeO2");
    auto force_lcao = run_lcao_force("CeO2");
    for (int iat = 0; iat < nat; iat++)
        for (int i = 0; i < 3; i++)
            EXPECT_NEAR(force_pw[iat][i], force_lcao[iat][i], 1e-3);  // < 1 mRy/Bohr
}
```

## Acceptance Criteria

- [ ] CeO2 PW DFT+U 力与 LCAO 一致（误差 < 1 mRy/Bohr）
- [ ] 力的对称性正确
