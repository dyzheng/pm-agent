# FE-000: 赝势库调研与收集

## Objective

系统调研现有稀土f_in_valence模守恒赝势库：PseudoDojo (ONCVPSP), PSlibrary (QE), SG15, GBRV, JTH。收集可用赝势，记录每个赝势的参考构型、截断半径、lmax、验证状态。建立赝势库索引。

## Reference Code

### ABACUS 赝势读取代码

**`/root/abacus-develop/source/source_cell/read_pp.h`** (130 lines)
- `Pseudopot_upf` 类 — 赝势读取主类
- `init_pseudo_reader()` — 初始化赝势读取器，自动检测 UPF 版本
- `read_pseudo_upf()` — 读取 UPF v1.0 格式
- `read_pseudo_upf201()` — 读取 UPF v2.0.1 格式

**`/root/abacus-develop/source/source_cell/read_pp.cpp`** (497 lines)
- 赝势读取主逻辑，解析 header、mesh、nlcc、local、nonlocal、pswfc 等段
- `read_pseudo_header()` — 解析元素符号、z_valence、lmax、mesh_size
- `read_pseudo_nl()` — 解析非局域赝势 beta 投影子

**`/root/abacus-develop/source/source_cell/read_pp_upf100.cpp`** (530 lines)
- UPF v1.0 格式解析器
- 旧格式（QE 5.x 及更早），部分 PSlibrary 赝势使用此格式

**`/root/abacus-develop/source/source_cell/read_pp_upf201.cpp`** (927 lines)
- UPF v2.0.1 格式解析器（XML-like）
- PseudoDojo、SG15 等现代赝势库均使用此格式
- 支持 SOC（自旋轨道耦合）赝势的 `PP_SPIN_ORB` 段

**`/root/abacus-develop/source/source_cell/pseudo.h`** (91 lines)
- `pseudo` 基类
- `lmax` — 最大角动量量子数（f 电子需要 lmax >= 3）
- `zv` — 价电子数
- `nchi` — 原子波函数数目
- `nbeta` — beta 投影子数目

**`/root/abacus-develop/source/source_cell/atom_pseudo.h`** (53 lines)
- `Atom_pseudo` 类，继承 `pseudo`
- 包含 SOC 支持字段：`has_so`, `jchi[]`, `jjj[]`
- f_in_valence 赝势需要 `lmax >= 3` 且对应 l=3 的 beta 投影子

### 赝势库来源

**PseudoDojo** (http://www.pseudo-dojo.org/)
- ONCVPSP 模守恒赝势，UPF2 格式
- 提供 stringent/standard 两种精度级别
- 稀土元素覆盖：La-Lu 全覆盖，含 f_in_valence 版本

**SG15** (http://www.quantum-simulation.org/potentials/sg15_oncv/)
- ONCV 模守恒赝势，UPF2 格式
- 稀土覆盖有限，部分元素缺少 f_in_valence 版本

**PSlibrary** (QE 官方赝势库)
- PAW 和 US 赝势为主，部分 NC 赝势
- UPF1/UPF2 格式混合

**GBRV** (https://www.physics.rutgers.edu/gbrv/)
- US 赝势为主，稀土覆盖有限

**JTH** (https://www.abinit.org/pseudopotentials)
- PAW 数据集，需转换为 UPF 格式才能用于 ABACUS

## Implementation Guide

### 调研方法论

本任务为调研/收集任务，非代码实现。工作流程：

1. **数据库扫描**: 逐一访问 PseudoDojo、SG15、PSlibrary、GBRV、JTH 官方站点
2. **元素覆盖**: 目标元素 La(57) 到 Lu(71)，重点关注 La、Ce、Nd、Sm、Eu、Gd、Tb
3. **格式筛选**: 优先选择 UPF2 格式（ABACUS 原生支持），UPF1 次之
4. **f_in_valence 判定**: 检查赝势 header 中价电子构型是否包含 4f 轨道

### 赝势元数据记录规范

每个赝势需记录以下字段：

| 字段 | 类型 | 说明 |
|------|------|------|
| `element` | string | 元素符号 |
| `source` | string | 来源库名（PseudoDojo/SG15/PSlibrary/GBRV/JTH） |
| `format` | string | UPF1 或 UPF2 |
| `lmax` | int | 最大角动量（f 电子需 >= 3） |
| `zv` | float | 价电子数 |
| `f_in_valence` | bool | 4f 电子是否在价态 |
| `reference_config` | string | 参考构型（如 `[Xe] 4f1 5d1 6s2`） |
| `cutoff_wfc` | float | 波函数截断能 (Ry) |
| `cutoff_rho` | float | 电荷密度截断能 (Ry) |
| `has_so` | bool | 是否包含 SOC 信息 |
| `validation_status` | string | 验证状态（untested/passed/failed） |
| `path` | string | 本地文件路径 |

### 质量评估标准

- **log derivative 测试**: 在多个能量点比较全电子与赝势的 log derivative
- **可转移性**: 在不同化学环境（氧化物、氮化物、金属）中的表现
- **ghost state 检查**: 确认无非物理束缚态
- **截断能收敛**: 记录达到 1 meV/atom 精度所需的截断能

### 目录结构

```
pseudopotentials/rare_earth/
├── inventory.json              # 赝势索引（所有元素的元数据）
├── La/
│   ├── PseudoDojo/
│   │   ├── La.upf2             # stringent 版本
│   │   └── metadata.json       # 单个赝势的详细元数据
│   └── SG15/
│       ├── La_ONCV_PBE-1.2.upf
│       └── metadata.json
├── Ce/
│   ├── PseudoDojo/
│   └── SG15/
├── ...（其他元素）
└── quality_report.md           # 质量评估汇总
```

### Critical Implementation Details

- **f_in_valence 判定方法**: 解析 UPF header 中的 `PP_HEADER` 段，检查 `number_of_wfc` 和各 wfc 的 `l` 值，若存在 l=3 的价态波函数则为 f_in_valence
- **ABACUS 兼容性**: ABACUS 的 `read_pp_upf201.cpp` 支持标准 UPF2 格式，但部分非标准扩展（如 ONCVPSP 的 `PP_PSWFC` 段格式）可能需要验证
- **SOC 赝势**: 含 SOC 的赝势在 `PP_SPIN_ORB` 段有额外的 j 量子数信息，`atom_pseudo.h` 中的 `jchi[]` 和 `jjj[]` 字段对应
- **截断能估算**: PseudoDojo 提供推荐截断能（hints），SG15 需要自行收敛测试
- **文件命名**: 统一使用 `{Element}_{Source}_{Type}.upf` 格式，避免混淆

## TDD Test Plan

### Tests to Write FIRST

```python
# test_pp_inventory.py
import pytest
import json
import os

PP_BASE = "pseudopotentials/rare_earth"
INVENTORY = os.path.join(PP_BASE, "inventory.json")

def test_pp_inventory_completeness():
    """每个目标元素至少有1个f_in_valence赝势"""
    with open(INVENTORY) as f:
        inv = json.load(f)
    required = ["La", "Ce", "Nd", "Sm", "Eu", "Gd", "Tb"]
    for elem in required:
        assert elem in inv, f"Missing element: {elem}"
        pp_list = inv[elem]
        f_in_val = [p for p in pp_list if p.get("f_in_valence")]
        assert len(f_in_val) >= 1, f"{elem}: no f_in_valence PP found"

def test_pp_metadata_fields():
    """每个赝势记录包含必要字段"""
    with open(INVENTORY) as f:
        inv = json.load(f)
    required_fields = [
        "source", "format", "lmax", "zv", "f_in_valence",
        "reference_config", "cutoff_wfc", "cutoff_rho"
    ]
    for elem, pp_list in inv.items():
        for pp in pp_list:
            for field in required_fields:
                assert field in pp, f"{elem}: missing field '{field}'"

def test_pp_lmax_for_f_electrons():
    """f_in_valence 赝势的 lmax 必须 >= 3"""
    with open(INVENTORY) as f:
        inv = json.load(f)
    for elem, pp_list in inv.items():
        for pp in pp_list:
            if pp.get("f_in_valence"):
                assert pp["lmax"] >= 3, (
                    f"{elem}/{pp['source']}: f_in_valence but lmax={pp['lmax']}"
                )

def test_pp_file_exists():
    """每个记录的赝势文件实际存在"""
    with open(INVENTORY) as f:
        inv = json.load(f)
    for elem, pp_list in inv.items():
        for pp in pp_list:
            assert os.path.exists(pp["path"]), f"PP file not found: {pp['path']}"

def test_directory_structure():
    """目录结构符合规范"""
    required_elements = ["La", "Ce", "Nd", "Sm", "Eu", "Gd", "Tb"]
    for elem in required_elements:
        elem_dir = os.path.join(PP_BASE, elem)
        assert os.path.isdir(elem_dir), f"Missing directory: {elem_dir}"
```

## Acceptance Criteria

- [ ] 至少覆盖La/Ce/Nd/Sm/Eu/Gd/Tb 7种元素的赝势可用性报告
- [ ] 每个元素至少1个f_in_valence赝势
- [ ] 记录赝势来源、参数、质量评估
- [ ] 建立赝势库目录结构
