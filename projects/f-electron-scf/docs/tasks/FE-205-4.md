# FE-205-4: 与 DFT+U omc 协同及端到端验证

## Objective

[工程追赶] 实现与 DFT+U occupation matrix control 的协同，并完成端到端验证：
(1) 当 DFT+U 的 omc 开启时，约束目标自动从 omc 的目标占据矩阵推导 n_target
(2) 支持 Hund 规则自动构造初始占据矩阵（Ce³⁺ f¹, Gd³⁺ f⁷ 等）
(3) 端到端测试：Ce2O3 体系，约束 Ce 的 f 电子数到 1.0±0.1，释放约束后验证占据数保持
(4) 测试 CeO2（f⁰）和 GdN（f⁷）作为额外验证
(5) 输出诊断信息：每步的 n_f、λ、V_penalty、总能量

## Reference Code

### Source Code (to migrate from)

本任务依赖 FE-205-1/2/3 的产出（ChargeConstraint 完整模块），不涉及外部代码迁移。

### Target Code (to integrate with)

**`/root/abacus-develop/source/source_lcao/module_dftu/dftu.h`** (354 行) — DFT+U 核心类
- `omc` (静态成员, 第 63 行): occupation matrix control 开关。`omc=1` 表示从文件读取初始占据矩阵，`omc=2` 表示固定占据矩阵
- `locale` (第 169 行): `vector<vector<vector<vector<matrix>>>>` — 当前占据矩阵 `locale[iat][l][n][spin](m1,m2)`，f 电子对应 `l=3`，矩阵维度 7×7
- `locale_save` (第 170 行): 上一步的占据矩阵，用于混合
- `mixing_dftu` (第 64 行): 是否对占据矩阵进行混合

**`/root/abacus-develop/source/source_lcao/module_dftu/dftu_io.cpp`** (538 行) — omc 文件读写
- `read_occup_m()` (第 234 行): 从 `initial_onsite.dm` 或 `onsite.dm` 读取目标占据矩阵。当 `omc > 0` 时执行（第 248 行）。读取的矩阵存入 `locale` 数组
- 文件格式: 按原子遍历，每个关联轨道输出 (2l+1)×(2l+1) 矩阵

**`/root/abacus-develop/source/source_lcao/module_dftu/dftu.cpp`** (482 行) — DFT+U 初始化
- `init()` (第 45 行): 初始化 `locale` 数组维度，读取 omc 文件（第 205 行），设置 `initialed_locale` 标志（第 211 行）
- `U0[]` / `U[]`: 目标 U 值和当前 U 值数组

**`/root/abacus-develop/source/source_lcao/module_dftu/dftu_occup.cpp`** (541 行) — 占据矩阵操作
- `mix_locale()` (第 85 行): 占据矩阵 Pulay 混合，参数为 `mixing_beta`
- `copy_locale()` (第 9 行): `locale` → `locale_save` 拷贝
- `zero_locale()` (第 47 行): 清零 `locale`

**`/root/abacus-develop/source/source_esolver/esolver_ks_lcao.cpp`** (572 行) — LCAO SCF 循环
- `iter_init()` (第 320 行): 每步初始化，DFT+U 相关操作在此执行
- `iter_finish()` (第 463 行): 每步结束，占据矩阵更新和混合在此执行

### Prior Art / Related Implementations

**VASP OCCMATRIX**: 通过 `OCCMATRIX` 标签读取目标占据矩阵，支持固定或初始化两种模式。与 ABACUS 的 `omc=1/2` 对应。

**QE `starting_ns_eigenvalue`**: 在 `pw.x` 输入中指定 DFT+U 轨道的初始占据本征值。仅支持对角元素，不支持完整占据矩阵。

**Hund 规则占据**: 对于 f 电子，Hund 第一规则要求最大化自旋。对于 l=3 (f 轨道, 2l+1=7 个轨道)：
- f¹ (Ce³⁺): 一个电子占据最低 m 轨道，自旋向上
- f³ (Nd³⁺): 三个电子分别占据 m=-3,-2,-1，自旋向上
- f⁷ (Gd³⁺, Eu²⁺): 半满，7 个电子全部自旋向上
- f⁰ (Ce⁴⁺ in CeO2): 空 f 壳层

**ABACUS DeltaSpin** (`/root/abacus-develop/source/source_lcao/module_deltaspin/spin_constrain.h`): `SpinConstrain` 类实现自旋约束 DFT，通过拉格朗日乘子 lambda 约束局域磁矩。其 `lambda_loop.cpp` 中的 SCF 内循环集成模式可参考。

## Implementation Guide

### Architecture Decisions

1. **omc 协同策略**: 当 `omc > 0` 且 `chg_constraint` 激活时，`ChargeConstraint` 自动从 omc 目标矩阵提取 `n_target`。具体做法：`n_target = Tr(locale_target[iat][l=3][n][spin])` 对所有自旋求和。这是有意的信息降维 — 完整占据矩阵由 omc 控制轨道分辨的占据，`ChargeConstraint` 只约束总 f 电子数。

2. **Hund 规则查找表**: 静态 `std::map<std::pair<std::string, int>, std::vector<double>>` 存储 `(元素, 氧化态) → 对角占据向量`。仅存储自旋向上通道的对角元素，自旋向下全为 0（Hund 第一规则最大化自旋）。查找表硬编码常见镧系/锕系元素，用户也可通过 omc 文件覆盖。

3. **`ChargeConstraint::from_omc()` 工厂方法**: 从 `Plus_U` 实例和原子索引创建 `ChargeConstraint`，自动提取 `n_target`。避免用户手动指定 `n_target` 与 omc 矩阵不一致。

4. **诊断输出**: 每 SCF 步输出一行到 `constraint_log.dat`，格式为 `step  n_f  lambda  V_penalty  E_total`。同时在标准输出中以 `CONSTRAINT:` 前缀打印关键信息，便于 grep 过滤。

5. **端到端测试框架**: 使用 ABACUS 的集成测试框架，准备 Ce2O3、CeO2、GdN 三个测试体系的 INPUT/STRU/KPT 文件。测试流程：约束 SCF → 检查 n_f → 释放约束 SCF → 检查 n_f 保持。

### Data Structure Mapping

| 组件 | 变量/方法 | 用途 |
|------|-----------|------|
| `Plus_U::omc` | `int` (0/1/2) | omc 开关，0=关闭, 1=初始化, 2=固定 |
| `Plus_U::locale[iat][l][n][spin]` | `matrix(2l+1, 2l+1)` | 当前占据矩阵，f 电子 l=3 |
| `ChargeConstraint::from_omc(plus_u, iat)` | 工厂方法 | 从 omc 目标矩阵创建约束 |
| `ChargeConstraint::n_target_` | `double` | 目标 f 电子数 = Tr(omc_matrix) |
| `hund_rule_locale(element, ox_state)` | 自由函数 | 返回 Hund 规则对角占据矩阵 |
| Hund 查找表 | `map<pair<string,int>, vector<double>>` | (元素, 氧化态) → 7 元素对角向量 |
| `constraint_log.dat` | 输出文件 | 每步诊断: step, n_f, lambda, V_pen, E_tot |

### Critical Implementation Details

1. **omc 矩阵到 n_target 的信息降维**: omc 矩阵是完整的 (2l+1)×(2l+1) 矩阵（可能含非对角元素），`n_target` 仅取其迹。这意味着 `ChargeConstraint` 不约束轨道分辨的占据，只约束总数。当 omc 矩阵含非对角元素时（如 SOC 情况），迹仍然等于总电子数，物理上是正确的。

2. **omc 与 chg_constraint 的一致性检查**: 初始化时验证 `n_target == Tr(omc_matrix)`。如果用户同时手动指定了 `n_target` 且与 omc 矩阵的迹不一致，发出警告并以 omc 矩阵的迹为准。

3. **Hund 规则需要 nspin >= 2**: Hund 规则生成的占据矩阵是自旋极化的（自旋向上通道有占据，自旋向下为空）。如果 `nspin=1`（非自旋极化计算），Hund 规则不适用，应报错退出。对于 `nspin=4`（SOC），需要将自旋向上/向下映射到 spinor 的两个分量。

4. **端到端测试的数值容差**:
   - 约束阶段: `|n_f - n_target| < 0.1`（约束精度受 lambda 衰减速率影响）
   - 释放后保持: `|n_f - n_target| < 0.15`（允许略大偏差，因为无约束力）
   - 总能量: 约束 SCF 的总能量应高于无约束 SCF（惩罚势贡献为正）
   - 释放后总能量应低于约束阶段

5. **诊断输出的线程安全**: MPI 并行时仅 rank 0 写入 `constraint_log.dat`。使用 `GlobalV::ofs_running` 的模式，在 `init()` 时打开文件，每步追加写入。

6. **CeO2 (f⁰) 特殊处理**: Ce⁴⁺ 的 f 壳层为空，`n_target = 0`。此时约束的作用是防止 f 电子意外占据（DFT 自洽中 CeO2 的 f 轨道可能被错误部分占据）。Lambda 衰减后 n_f 应保持接近 0。

## TDD Test Plan

### Tests to Write FIRST

```cpp
#include <gtest/gtest.h>
#include <cmath>
#include <complex>
#include <map>
#include <string>
#include <vector>
#include <utility>

// ============================================================
// 模拟 ABACUS 的 matrix 类用于单元测试
// ============================================================
struct SimpleMatrix
{
    int nr, nc;
    std::vector<double> data;
    SimpleMatrix(int r, int c) : nr(r), nc(c), data(r * c, 0.0) {}
    double& operator()(int i, int j) { return data[i * nc + j]; }
    double operator()(int i, int j) const { return data[i * nc + j]; }
};

// ============================================================
// Hund 规则查找表和生成函数
// ============================================================

// 返回 f 轨道 (l=3) 的 Hund 规则对角占据向量 (7 个元素, 自旋向上通道)
std::vector<double> hund_rule_f_diagonal(const std::string& element, int oxidation_state);

// 返回完整的 7x7 占据矩阵 (对角矩阵)
SimpleMatrix hund_rule_locale(const std::string& element, int oxidation_state);

// ============================================================
// 测试: omc 协同
// ============================================================
class OmcCooperationTest : public testing::Test
{
  protected:
    // 构造 Ce3+ (f^1) 的 omc 目标矩阵: 对角, 仅 m=0 位置为 1
    SimpleMatrix make_Ce3plus_omc()
    {
        SimpleMatrix mat(7, 7);
        mat(0, 0) = 1.0;  // 一个 f 电子在最低 m 轨道
        return mat;
    }

    // 构造 Gd3+ (f^7) 的 omc 目标矩阵: 对角, 全 1
    SimpleMatrix make_Gd3plus_omc()
    {
        SimpleMatrix mat(7, 7);
        for (int m = 0; m < 7; m++)
        {
            mat(m, m) = 1.0;
        }
        return mat;
    }

    // 构造 Ce4+ (f^0) 的 omc 目标矩阵: 全 0
    SimpleMatrix make_Ce4plus_omc()
    {
        SimpleMatrix mat(7, 7);
        return mat;
    }

    // 从 omc 矩阵提取 n_target (取迹)
    double n_target_from_omc(const SimpleMatrix& omc_mat)
    {
        double trace = 0.0;
        for (int m = 0; m < 7; m++)
        {
            trace += omc_mat(m, m);
        }
        return trace;
    }
};

TEST_F(OmcCooperationTest, NTargetFromOmcCe3Plus)
{
    auto omc = make_Ce3plus_omc();
    EXPECT_NEAR(n_target_from_omc(omc), 1.0, 1e-10);
}

TEST_F(OmcCooperationTest, NTargetFromOmcGd3Plus)
{
    auto omc = make_Gd3plus_omc();
    EXPECT_NEAR(n_target_from_omc(omc), 7.0, 1e-10);
}

TEST_F(OmcCooperationTest, NTargetFromOmcCe4Plus)
{
    auto omc = make_Ce4plus_omc();
    EXPECT_NEAR(n_target_from_omc(omc), 0.0, 1e-10);
}

// ============================================================
// 测试: Hund 规则自动构造
// ============================================================
class HundRuleTest : public testing::Test
{
  protected:
    // Hund 规则查找表: (元素, 氧化态) -> f 电子数
    static const std::map<std::pair<std::string, int>, int> f_electron_count;
};

const std::map<std::pair<std::string, int>, int> HundRuleTest::f_electron_count = {
    {{"Ce", 3}, 1},   // Ce3+ = f^1
    {{"Ce", 4}, 0},   // Ce4+ = f^0
    {{"Pr", 3}, 2},   // Pr3+ = f^2
    {{"Nd", 3}, 3},   // Nd3+ = f^3
    {{"Sm", 3}, 5},   // Sm3+ = f^5
    {{"Eu", 2}, 7},   // Eu2+ = f^7
    {{"Eu", 3}, 6},   // Eu3+ = f^6
    {{"Gd", 3}, 7},   // Gd3+ = f^7
    {{"Tb", 3}, 8},   // Tb3+ = f^8
    {{"Dy", 3}, 9},   // Dy3+ = f^9
    {{"U",  4}, 2},   // U4+  = f^2
};

TEST_F(HundRuleTest, Ce3PlusF1)
{
    auto locale = hund_rule_locale("Ce", 3);
    // f^1: 一个电子在 m=0 (最低 m_l)
    double trace = 0.0;
    for (int m = 0; m < 7; m++)
    {
        trace += locale(m, m);
    }
    EXPECT_NEAR(trace, 1.0, 1e-10);
    EXPECT_NEAR(locale(0, 0), 1.0, 1e-10);  // 最低 m 占据
    EXPECT_NEAR(locale(1, 1), 0.0, 1e-10);  // 其余为空
}

TEST_F(HundRuleTest, Gd3PlusF7HalfFilled)
{
    auto locale = hund_rule_locale("Gd", 3);
    // f^7: 半满, 所有 7 个轨道各一个电子 (自旋向上)
    double trace = 0.0;
    for (int m = 0; m < 7; m++)
    {
        trace += locale(m, m);
    }
    EXPECT_NEAR(trace, 7.0, 1e-10);
    for (int m = 0; m < 7; m++)
    {
        EXPECT_NEAR(locale(m, m), 1.0, 1e-10);
    }
}

TEST_F(HundRuleTest, Nd3PlusF3)
{
    auto locale = hund_rule_locale("Nd", 3);
    // f^3: 三个电子占据 m=0,1,2
    double trace = 0.0;
    for (int m = 0; m < 7; m++)
    {
        trace += locale(m, m);
    }
    EXPECT_NEAR(trace, 3.0, 1e-10);
    // 前 3 个轨道占据
    for (int m = 0; m < 3; m++)
    {
        EXPECT_NEAR(locale(m, m), 1.0, 1e-10);
    }
    // 后 4 个轨道为空
    for (int m = 3; m < 7; m++)
    {
        EXPECT_NEAR(locale(m, m), 0.0, 1e-10);
    }
}

TEST_F(HundRuleTest, Ce4PlusF0Empty)
{
    auto locale = hund_rule_locale("Ce", 4);
    double trace = 0.0;
    for (int m = 0; m < 7; m++)
    {
        trace += locale(m, m);
    }
    EXPECT_NEAR(trace, 0.0, 1e-10);
}

TEST_F(HundRuleTest, OffDiagonalIsZero)
{
    // Hund 规则生成的矩阵应为对角矩阵
    auto locale = hund_rule_locale("Nd", 3);
    for (int m1 = 0; m1 < 7; m1++)
    {
        for (int m2 = 0; m2 < 7; m2++)
        {
            if (m1 != m2)
            {
                EXPECT_NEAR(locale(m1, m2), 0.0, 1e-10);
            }
        }
    }
}

// ============================================================
// 测试: 端到端约束与释放
// ============================================================
class EndToEndTest : public testing::Test
{
  protected:
    // 模拟约束 SCF: 返回最终 n_f
    struct SCFResult
    {
        double n_f;
        double e_total;
        double e_penalty;
        int nsteps;
    };

    // 模拟约束 SCF 过程
    SCFResult run_mock_constrained_scf(double n_target, double lambda0, double n_initial)
    {
        // 简化模型: n_f 在约束下指数趋近 n_target
        double n_f = n_initial;
        double e_penalty = 0.0;
        int nsteps = 100;
        for (int step = 0; step < nsteps; step++)
        {
            double lambda = lambda0 * std::exp(-step / 50.0);
            double force = -lambda * (n_f - n_target);
            n_f += 0.1 * force;  // 简化响应
            e_penalty = 0.5 * lambda * (n_f - n_target) * (n_f - n_target);
        }
        return {n_f, -100.0 + e_penalty, e_penalty, nsteps};
    }
};

TEST_F(EndToEndTest, Ce2O3ConstraintConverges)
{
    // Ce3+ 目标 f^1, 初始 n_f = 0.5 (DFT 自洽可能给出的错误值)
    auto result = run_mock_constrained_scf(
        /*n_target=*/1.0, /*lambda0=*/10.0, /*n_initial=*/0.5);
    EXPECT_NEAR(result.n_f, 1.0, 0.1);
}

TEST_F(EndToEndTest, CeO2ConstraintToZero)
{
    // Ce4+ 目标 f^0, 初始 n_f = 0.3 (DFT 可能错误部分占据)
    auto result = run_mock_constrained_scf(
        /*n_target=*/0.0, /*lambda0=*/10.0, /*n_initial=*/0.3);
    EXPECT_NEAR(result.n_f, 0.0, 0.1);
}

TEST_F(EndToEndTest, GdNConstraintHalfFilled)
{
    // Gd3+ 目标 f^7, 初始 n_f = 5.0
    auto result = run_mock_constrained_scf(
        /*n_target=*/7.0, /*lambda0=*/10.0, /*n_initial=*/5.0);
    EXPECT_NEAR(result.n_f, 7.0, 0.15);
}

// ============================================================
// 测试: 诊断输出格式
// ============================================================
class DiagnosticOutputTest : public testing::Test
{
  protected:
    struct DiagLine
    {
        int step;
        double n_f;
        double lambda;
        double v_penalty;
        double e_total;
    };

    // 解析一行诊断输出
    DiagLine parse_line(const std::string& line)
    {
        DiagLine d;
        std::istringstream iss(line);
        iss >> d.step >> d.n_f >> d.lambda >> d.v_penalty >> d.e_total;
        return d;
    }
};

TEST_F(DiagnosticOutputTest, FormatIsCorrect)
{
    // 模拟诊断输出行
    std::string line = "   5   0.9500   8.1873   0.0204  -99.9796";
    auto d = parse_line(line);

    EXPECT_EQ(d.step, 5);
    EXPECT_NEAR(d.n_f, 0.95, 1e-4);
    EXPECT_GT(d.lambda, 0.0);
    EXPECT_GE(d.v_penalty, 0.0);
    EXPECT_LT(d.e_total, 0.0);  // 总能量通常为负
}

TEST_F(DiagnosticOutputTest, LambdaDecreasesMonontonically)
{
    // 验证诊断输出中 lambda 单调递减
    std::vector<std::string> lines = {
        "   0   0.5000  10.0000   1.2500  -98.7500",
        "   1   0.6000   9.8020   0.7841  -99.2159",
        "   2   0.7000   9.6079   0.4323  -99.5677",
    };

    double prev_lambda = 1e10;
    for (const auto& line : lines)
    {
        auto d = parse_line(line);
        EXPECT_LT(d.lambda, prev_lambda);
        prev_lambda = d.lambda;
    }
}
```

## Acceptance Criteria

- [ ] Ce2O3 中 Ce 的 f 电子数可被约束到目标值±0.1
- [ ] 释放约束后占据数保持
- [ ] 与 DFT+U 占据矩阵控制协同工作
- [ ] CeO2 和 GdN 验证通过
- [ ] 诊断输出完整
