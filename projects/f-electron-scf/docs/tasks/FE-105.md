# FE-105: mixing_dftu（占据矩阵 mixing）

## Objective

实现占据矩阵的 Broyden mixing，改善 DFT+U 收敛性。添加 mix_locale() 方法，mixing_dftu 输入参数，震荡体系自动开启 mixing_dftu。

## Reference Code

### Source Code (zdy-tmp 参考实现)

**`/root/abacus-zdy-tmp/source/source_lcao/module_dftu/dftu_occup.cpp`**
- `mix_locale()` — 占据矩阵 Broyden mixing 实现
  - 使用 `locale` 和 `locale_save` 进行 mixing
  - mixing 公式: locale_new = (1-β) × locale_old + β × locale_scf
  - Broyden 方案使用历史信息加速收敛

**`/root/abacus-zdy-tmp/source/source_lcao/module_dftu/dftu_pw.cpp`**
- `cal_occ_pw()` 中调用 `mix_locale()` 的位置和条件
  - 条件: `mixing_dftu == true && iter > 1`

**`/root/abacus-zdy-tmp/source/source_lcao/module_dftu/dftu.h`**
- `bool mixing_dftu` — 输入参数，控制是否启用占据矩阵 mixing
- `locale_save` — 上一步的 locale，用于 mixing

### Target Code (develop 分支)

**`/root/abacus-develop/source/source_lcao/module_dftu/dftu.h`** (354 lines)
- `Plus_U` 类 — 需添加 `mixing_dftu` 成员和 `mix_locale()` 方法声明
- 已有 `locale`, `locale_save` 成员

**`/root/abacus-develop/source/source_lcao/module_dftu/dftu_occup.cpp`** (541 lines)
- `copy_locale()`, `zero_locale()` — 已有 locale 操作工具
- 需添加 `mix_locale()` 实现

**`/root/abacus-develop/source/source_lcao/module_dftu/dftu_pw.cpp`** (219 lines)
- `cal_occ_pw()` — 需在适当位置调用 `mix_locale()`

**`/root/abacus-develop/source/source_estate/module_charge/chgmixing.cpp`**
- `chgmixing_ks_pw()`:120-172 — 电荷 mixing 与 DFT+U mixing 的协调点
- mixing_restart 逻辑需与 mixing_dftu 兼容

### Prior Art

**`/root/abacus-develop/source/source_estate/module_charge/charge_mixing.cpp`** (259 lines)
- `Charge_Mixing::set_mixing()` — 电荷密度 Broyden mixing 的实现
- 可参考 Broyden mixing 的数据结构和算法

## Implementation Guide

### Architecture Decisions

- mixing_dftu 作为独立的 mixing 通道，与电荷密度 mixing 解耦
- 使用简单的线性 mixing 作为初始实现（β × new + (1-β) × old），后续可升级为 Broyden
- 震荡检测: 当连续 N 步能量变化符号交替时，自动开启 mixing_dftu

### Data Structure Mapping

| 变量 | 类型 | 说明 |
|------|------|------|
| `locale[iat][l][n][spin]` | `vector<vector<vector<vector<complex<double>>>>>` | 当前步占据矩阵 |
| `locale_save[iat][l][n][spin]` | 同上 | 上一步占据矩阵 |
| `mixing_dftu` | `bool` | 是否启用 mixing |
| `mixing_beta` | `double` | mixing 参数（从 cal_occ_pw 传入） |

### Critical Implementation Details

- **mix_locale() 调用时机**: 在 `cal_occ_pw()` 中，计算完新 locale 后、计算 V_U 前
- **首步跳过**: iter=1 时没有 locale_save，不做 mixing
- **copy_locale()**: 在 mixing 前需要 `copy_locale()` 保存当前 locale 到 locale_save
- **与 charge mixing 的交互**: mixing_dftu 和 charge mixing 是独立的，但 mixing_restart 时两者都需要重置
- **自动开启逻辑**: 检测 `energy_u` 的震荡模式（连续 3 步符号交替），自动设置 mixing_dftu=true

## TDD Test Plan

### Tests to Write FIRST

```cpp
TEST_F(MixingDftuTest, MixLocaleLinear) {
    // 线性 mixing: locale_new = (1-β)*locale_old + β*locale_scf
    set_locale_old({{1.0, 0.0}, {0.0, 1.0}});
    set_locale_scf({{0.8, 0.1}, {0.1, 0.8}});
    Plus_U::get_instance().mix_locale(0.3);  // β=0.3
    auto& locale = Plus_U::get_instance().locale;
    // Expected: 0.7*1.0 + 0.3*0.8 = 0.94
    EXPECT_NEAR(locale[0][0].real(), 0.94, 1e-10);
}

TEST_F(MixingDftuTest, MixingDisabledByDefault) {
    // mixing_dftu=false 时不做 mixing
    EXPECT_FALSE(Plus_U::get_instance().mixing_dftu);
}

TEST_F(MixingDftuTest, OscillationAutoEnable) {
    // 连续震荡时自动开启
    simulate_oscillating_energy(5);
    EXPECT_TRUE(Plus_U::get_instance().mixing_dftu);
}
```

## Acceptance Criteria

- [ ] mixing_dftu=true 时占据矩阵使用 Broyden mixing
- [ ] 震荡体系自动开启 mixing_dftu
- [ ] 不影响非 DFT+U 计算
