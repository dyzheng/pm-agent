# FE-205-3: Lambda 调度策略与 SCF 集成

## Objective

[工程追赶] 实现约束强度的逐步释放机制并集成到 SCF 主循环：
(1) Lambda 调度器：支持指数衰减 λ(t) = λ₀·exp(-t/τ) 和线性衰减两种模式，可配置 λ₀（默认 10.0 eV）、τ（默认 50 步）、λ_final（默认 0.0）
(2) 在 SCF 主循环的每步调用 ChargeConstraint::update(scf_step)，更新 λ 值并重新计算惩罚势
(3) 与 FE-204 的能量监控协同：当能量回退触发时暂停 λ 衰减
(4) 收敛判据扩展：同时满足能量收敛 ΔE < 10⁻⁶ eV 和占据收敛 |n_f - n_target| < 0.05

## Reference Code

### Source Code (to migrate from)

本任务依赖 FE-205-1/2 的产出，不涉及外部代码迁移。参考以下已有的调度/约束机制：

**`/root/abacus-develop/source/source_lcao/module_dftu/dftu.h`** (354 行) — U-ramping 调度参考
- `uramping` (静态成员, 第 62 行): 每步 U 增量，`LambdaScheduler` 可参考此"每步更新"模式
- `uramping_update()` (第 55 行): 线性递增直到目标值，lambda 调度器需要反向操作（递减到 0）

**`/root/abacus-develop/source/source_lcao/module_dftu/dftu.cpp`** (482 行) — U-ramping 实现
- `uramping_update()` (第 394 行): 核心逻辑 `U[i] += uramping`，直到 `U[i] >= U0[i]`。Lambda 调度器采用类似的"每步更新 + 边界检查"模式

**`/root/abacus-develop/source/source_lcao/module_deltaspin/lambda_loop.cpp`** — DeltaSpin lambda 优化循环
- `run_lambda_loop()` (第 28 行): 自洽优化 lambda 使自旋达到目标值。本任务的 lambda 是惩罚强度参数，与 DeltaSpin 的 lambda（拉格朗日乘子）概念不同，但 SCF 集成模式可参考

### Target Code (to integrate with)

**`/root/abacus-develop/source/source_esolver/esolver_ks.cpp`** (349 行) — KS 求解器基类，SCF 主循环
- `runner()` (第 130 行): SCF 主循环入口，包含 `before_scf` → `iter_init` → `hamilt_solve` → `iter_finish` → `after_scf` 完整流程
- `iter_init()` (第 187 行): 每步初始化 — **lambda 更新的调用点**，必须在 Hamiltonian 构建之前
- `iter_finish()` (第 214 行): 每步结束 — **收敛判据扩展点**，当前仅检查 `drho`，需要增加占据数收敛条件
- `conv_esolver` (第 140 行): 收敛标志，需要同时满足能量和占据数条件

**`/root/abacus-develop/source/source_esolver/esolver_ks_pw.cpp`** (447 行) — PW 基 SCF 循环
- `iter_init()` (第 170 行): 调用基类 `iter_init()` 后执行 PW 特有初始化。ChargeConstraint 更新应在基类层面
- `iter_finish()` (第 273 行): 调用基类 `iter_finish()` 处理收敛判断

**`/root/abacus-develop/source/source_esolver/esolver_ks_lcao.cpp`** (572 行) — LCAO 基 SCF 循环
- `iter_init()` (第 320 行): 调用基类后执行 LCAO 特有初始化（DFT+U 相关）
- `iter_finish()` (第 463 行): LCAO 版本的收敛处理

**`/root/abacus-develop/source/source_estate/module_charge/charge_mixing.cpp`** (259 行) — 电荷混合
- `mix_reset()` (第 198 行): 重置混合历史。当 lambda 发生大幅跳变时需要调用，避免 Pulay 混合使用过时的历史向量

**`/root/abacus-develop/source/source_io/module_parameter/input_parameter.h`** (704 行) — 输入参数
- `smearing_sigma` (第 98 行): smearing 宽度
- `mixing_beta` (第 101 行): 混合系数，lambda 变化时可能需要临时降低

### Prior Art / Related Implementations

**ABACUS U-ramping** (`dftu.cpp:394`): 线性调度模式，每步 `U += uramping`。Lambda 调度器扩展为支持指数衰减和暂停/恢复。

**ABACUS DeltaSpin** (`lambda_loop.cpp:28`): 自洽优化 lambda 使自旋收敛到目标。本任务的 lambda 是预设衰减的惩罚强度，不需要自洽优化，但 SCF 内循环的集成模式（在 `iter_init` 中更新约束参数）可直接参考。

**QE `starting_ns_eigenvalue`**: 静态设置初始占据，无动态调度。

## Implementation Guide

### Architecture Decisions

1. **`LambdaScheduler` 独立类**: 放在 `source/source_lcao/module_dftu/lambda_scheduler.h/cpp`。职责单一：根据步数返回当前 lambda 值，支持暂停/恢复。不依赖 ABACUS 全局状态，便于单元测试。

2. **两种衰减模式**:
   - 指数衰减: `lambda(t) = lambda0 * exp(-t/tau)`，适合需要初期快速释放、后期精细调整的场景
   - 线性衰减: `lambda(t) = lambda0 * max(0, 1 - t/T)`，适合需要确定步数内完全释放的场景
   - 通过输入参数 `chg_constraint_decay_mode` 选择 (`"exp"` 或 `"linear"`)

3. **SCF 集成层级**: 在 `ESolver_KS::iter_init()` 基类中调用 `ChargeConstraint::update(iter)`，确保 PW 和 LCAO 两种基组都能使用。`update()` 内部调用 `LambdaScheduler::get(step)` 获取当前 lambda，然后重新计算惩罚势。

4. **暂停/恢复机制**: `LambdaScheduler` 维护 `paused_` 标志和 `paused_at_step_` 记录。暂停时 `get()` 返回暂停时刻的 lambda 值。恢复时从暂停点继续衰减（调整内部步数偏移）。

5. **收敛判据扩展**: 在 `ESolver_KS::iter_finish()` 中，当 `ChargeConstraint` 激活时，`conv_esolver` 需要额外满足 `|n_f - n_target| < occ_thr`（默认 0.05）。

### Data Structure Mapping

| 组件 | 变量/方法 | 用途 |
|------|-----------|------|
| `LambdaScheduler` | `lambda0_` | 初始 lambda 强度 (默认 10.0 eV) |
| `LambdaScheduler` | `tau_` | 指数衰减时间常数 (默认 50 步) |
| `LambdaScheduler` | `total_steps_` | 线性衰减总步数 (默认 100 步) |
| `LambdaScheduler` | `mode_` | 衰减模式: `"exp"` 或 `"linear"` |
| `LambdaScheduler` | `paused_` | 暂停标志 |
| `LambdaScheduler` | `paused_value_` | 暂停时的 lambda 值 |
| `LambdaScheduler` | `step_offset_` | 恢复后的步数偏移 |
| `LambdaScheduler` | `get(step) -> double` | 返回当前步的 lambda |
| `LambdaScheduler` | `pause()` | 暂停衰减 |
| `LambdaScheduler` | `resume()` | 恢复衰减 |
| `ChargeConstraint` | `scheduler_` | LambdaScheduler 实例 |
| `ChargeConstraint` | `update(step)` | 更新 lambda 并重算惩罚势 |
| `ESolver_KS` | `iter_init()` | 调用 `constraint.update(iter)` |
| `ESolver_KS` | `iter_finish()` | 检查占据数收敛条件 |
| `ESolver_KS` | `conv_esolver` | 扩展为 `conv_energy && conv_occupation` |

### Critical Implementation Details

1. **Lambda 更新必须在 Hamiltonian 构建之前**: `iter_init()` 中的调用顺序为 `constraint.update(iter)` → Hamiltonian 构建 → 对角化。如果在 Hamiltonian 构建之后更新 lambda，当前步使用的是上一步的惩罚势，导致收敛延迟。

2. **混合历史失效**: 当 lambda 变化导致 Hamiltonian 大幅改变时，Pulay 混合的历史向量不再有效。建议当 `|lambda(t) - lambda(t-1)| / lambda(t-1) > 0.2` 时调用 `mix_reset()`。这在指数衰减初期（lambda 变化最快时）尤其重要。

3. **最终 lambda 值**: 指数衰减理论上永远不到 0。当 `lambda < 1e-4 * lambda0` 时，直接设为 0，避免残余惩罚势影响最终结果。线性衰减在 `t >= T` 时自然为 0。

4. **暂停/恢复的步数处理**: 恢复时不能简单地从当前全局步数继续，因为暂停期间步数在增长。需要记录 `step_offset = global_step_at_resume - effective_step_at_pause`，之后 `effective_step = global_step - step_offset`。

5. **Checkpoint 保存**: lambda 调度器状态（当前 lambda、有效步数、暂停状态、步数偏移）需要写入 checkpoint 文件，格式与 DFT+U 的 `onsite.dm` 类似。重启时从 checkpoint 恢复调度器状态。

6. **与 FE-204 能量监控的接口**: FE-204 检测到能量异常上升时，通过回调或标志通知 `ChargeConstraint`，后者调用 `scheduler_.pause()`。能量稳定后调用 `scheduler_.resume()`。接口约定：`ChargeConstraint::on_energy_rollback()` 和 `ChargeConstraint::on_energy_stabilized()`。

## TDD Test Plan

### Tests to Write FIRST

```cpp
#include <gtest/gtest.h>
#include <cmath>
#include "module_dftu/lambda_scheduler.h"

class LambdaSchedulerTest : public testing::Test
{
  protected:
    void SetUp() override {}
};

// 测试指数衰减
TEST_F(LambdaSchedulerTest, ExponentialDecay)
{
    LambdaScheduler sched(/*lambda0=*/10.0, /*tau=*/50, /*mode=*/"exp");

    EXPECT_NEAR(sched.get(0), 10.0, 1e-10);
    EXPECT_NEAR(sched.get(50), 10.0 * std::exp(-1.0), 1e-6);
    EXPECT_NEAR(sched.get(200), 10.0 * std::exp(-4.0), 1e-6);
}

// 测试线性衰减
TEST_F(LambdaSchedulerTest, LinearDecay)
{
    LambdaScheduler sched(/*lambda0=*/10.0, /*T=*/100, /*mode=*/"linear");

    EXPECT_NEAR(sched.get(0), 10.0, 1e-10);
    EXPECT_NEAR(sched.get(50), 5.0, 1e-10);
    EXPECT_NEAR(sched.get(100), 0.0, 1e-10);
    EXPECT_NEAR(sched.get(150), 0.0, 1e-10);  // 超过 T 后 clamp 到 0
}

// 测试暂停和恢复
TEST_F(LambdaSchedulerTest, PauseResume)
{
    LambdaScheduler sched(10.0, 50, "exp");

    double val_at_10 = sched.get(10);
    sched.pause();

    // 暂停期间返回暂停时刻的值
    EXPECT_NEAR(sched.get(20), val_at_10, 1e-10);
    EXPECT_NEAR(sched.get(30), val_at_10, 1e-10);

    // 恢复后继续衰减
    sched.resume();
    EXPECT_LT(sched.get(30), val_at_10);
}

// 测试指数衰减最终截断到 0
TEST_F(LambdaSchedulerTest, ExponentialClampsToZero)
{
    LambdaScheduler sched(10.0, 50, "exp");

    // 足够多步后 lambda 应被截断为 0
    // lambda < 1e-4 * lambda0 = 0.001 时截断
    // 10 * exp(-t/50) < 0.001 => t > 50 * ln(10000) ~ 460
    EXPECT_NEAR(sched.get(500), 0.0, 1e-10);
}

// 测试多次暂停/恢复
TEST_F(LambdaSchedulerTest, MultiplePauseResume)
{
    LambdaScheduler sched(10.0, 50, "exp");

    // 第一次暂停
    double v1 = sched.get(10);
    sched.pause();
    EXPECT_NEAR(sched.get(20), v1, 1e-10);

    // 第一次恢复
    sched.resume();
    double v2 = sched.get(25);
    EXPECT_LT(v2, v1);

    // 第二次暂停
    sched.pause();
    EXPECT_NEAR(sched.get(35), v2, 1e-10);

    // 第二次恢复
    sched.resume();
    EXPECT_LT(sched.get(40), v2);
}

// 测试 SCF 集成：约束在 Hamiltonian 之前更新
class MockChargeConstraint
{
  public:
    int last_update_step = -1;
    double current_lambda = 0.0;
    LambdaScheduler scheduler;

    MockChargeConstraint(double lambda0, int tau)
        : scheduler(lambda0, tau, "exp") {}

    void update(int step)
    {
        current_lambda = scheduler.get(step);
        last_update_step = step;
    }
};

class SCFIntegrationTest : public testing::Test
{
  protected:
    void SetUp() override {}
};

TEST_F(SCFIntegrationTest, ConstraintUpdatedBeforeHamiltonian)
{
    MockChargeConstraint cc(10.0, 50);
    int hamilt_build_step = -1;

    // 模拟 iter_init: 先更新约束，再构建 Hamiltonian
    for (int iter = 0; iter < 10; iter++)
    {
        cc.update(iter);  // 约束更新
        hamilt_build_step = iter;  // Hamiltonian 构建

        // 验证约束在当前步已更新
        EXPECT_EQ(cc.last_update_step, iter);
        EXPECT_EQ(hamilt_build_step, iter);
    }

    // 验证 lambda 在衰减
    EXPECT_LT(cc.current_lambda, 10.0);
}

// 测试扩展收敛判据
TEST_F(SCFIntegrationTest, ConvergenceRequiresBothEnergyAndOccupation)
{
    double delta_e = 1e-7;      // 能量收敛
    double occ_diff = 0.03;     // 占据数收敛
    double e_thr = 1e-6;
    double occ_thr = 0.05;

    bool conv_energy = (delta_e < e_thr);
    bool conv_occupation = (occ_diff < occ_thr);
    bool conv_esolver = conv_energy && conv_occupation;

    EXPECT_TRUE(conv_esolver);

    // 能量收敛但占据数未收敛
    occ_diff = 0.1;
    conv_occupation = (occ_diff < occ_thr);
    conv_esolver = conv_energy && conv_occupation;
    EXPECT_FALSE(conv_esolver);

    // 占据数收敛但能量未收敛
    delta_e = 1e-5;
    occ_diff = 0.01;
    conv_energy = (delta_e < e_thr);
    conv_occupation = (occ_diff < occ_thr);
    conv_esolver = conv_energy && conv_occupation;
    EXPECT_FALSE(conv_esolver);
}
```

## Acceptance Criteria

- [ ] Lambda 从 λ₀ 逐步衰减到 0
- [ ] SCF 循环中正确调用约束更新
- [ ] 与能量监控（FE-204）协同工作
- [ ] 收敛判据包含占据数条件
