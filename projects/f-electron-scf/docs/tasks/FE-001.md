# FE-001: ABACUS DFT+U 代码深度审计

## Objective

[TERMINATED] 详细审计ABACUS DFT+U实现：dftu.cpp（主逻辑、U-ramping、omc）、dftu_occup.cpp（占据矩阵mixing）、dftu_hamilt.cpp（哈密顿量）、dftu_yukawa.cpp（自动U）、dftu_pw.cpp（PW限制）。记录每个函数的输入输出、数据流、已知限制。特别关注f电子（l=3）的处理路径。

终止原因：见 plans/2026-02-16-critical-review.md

## Reference Code

### 审计目标代码

**`/root/abacus-develop/source/source_lcao/module_dftu/dftu.h`** (354 lines)
- `Plus_U` 类 — DFT+U 主类，单例模式
- `init()` — 初始化 DFT+U 参数，分配 locale 数组
- `cal_energy_correction()` — 计算 DFT+U 能量修正 E_U
- `locale[][][][]` — 占据矩阵 `locale[iat][l][n][spin]`，核心数据结构
- `U[]` — Hubbard U 参数数组（每个原子类型一个值）
- `orbital_corr[]` — 关联轨道角动量（d: l=2, f: l=3）
- `uramping` — U-ramping 步长（逐步增大 U 值以改善收敛）
- `mixing_dftu` — 占据矩阵 mixing 开关

**`/root/abacus-develop/source/source_lcao/module_dftu/dftu.cpp`** (482 lines)
- `init()`:45 — 主初始化函数，读取 INPUT 参数，分配 locale 内存
- `cal_energy_correction()` — E_U = (U/2) Σ Tr[n(1-n)]，简化 Dudarev 公式
- U-ramping 逻辑：每个 SCF 步增加 `uramping` 直到达到目标 U 值

**`/root/abacus-develop/source/source_lcao/module_dftu/dftu_occup.cpp`** (541 lines)
- `cal_occup_m_k()`:128 — k 点版本的占据矩阵计算（复数）
- `cal_occup_m_gamma()`:384 — Gamma 点版本（实数）
- `mix_locale()` — 占据矩阵 mixing（线性混合旧/新 locale）
- `copy_locale()`, `zero_locale()` — locale 操作工具函数

**`/root/abacus-develop/source/source_lcao/module_dftu/dftu_hamilt.cpp`** (172 lines)
- `cal_eff_pot_mat_complex()`:8 — 复数有效势矩阵（k 点）
- `cal_eff_pot_mat_real()`:64 — 实数有效势矩阵（Gamma 点）
- V_eff = U(1/2·δ - n_mm')，Dudarev 形式的有效势

**`/root/abacus-develop/source/source_lcao/module_dftu/dftu_yukawa.cpp`** (295 lines)
- `cal_slater_UJ()`:111 — 从 Slater 积分计算 U 和 J 值
- `cal_yukawa_lambda()`:17 — 计算 Yukawa 屏蔽参数 λ
- 自动 U 功能：通过 Yukawa 屏蔽势自洽计算 U 值

**`/root/abacus-develop/source/source_lcao/module_dftu/dftu_pw.cpp`** (219 lines)
- `cal_occ_pw()`:117 — PW 基组下的占据矩阵计算
- `cal_VU_pot_pw()`:124 — PW 基组下的 DFT+U 势
- 已知限制：PW 基组的 DFT+U 功能不如 LCAO 完善

**`/root/abacus-develop/source/source_lcao/module_dftu/dftu_io.cpp`** (538 lines)
- `read_occup_m()`:234 — 从文件读取占据矩阵（omc 功能）
- `write_occup_m()`:76 — 输出占据矩阵到文件
- 支持 nspin=1/2/4 的占据矩阵 I/O

**`/root/abacus-develop/source/source_lcao/module_dftu/dftu_force.cpp`** (579 lines)
- `force_stress()`:25 — DFT+U 对力和应力的贡献
- 包含 Pulay 力修正项

**`/root/abacus-develop/source/source_lcao/module_dftu/dftu_tools.cpp`** (211 lines)
- 工具函数：Clebsch-Gordan 系数、Gaunt 系数、球谐函数旋转矩阵
- 这些工具函数对 l=2 和 l=3 均适用

## Implementation Guide

### 审计方法论

本任务为代码审计/文档任务，非代码实现。审计工作流程：

1. **逐文件审计**: 按上述 9 个源文件逐一分析
2. **数据流追踪**: 从 INPUT 参数读取 → init() → SCF 循环 → 占据矩阵 → 哈密顿量 → 力/应力
3. **f 电子路径标注**: 标记所有与 `orbital_corr` 和 `l` 值相关的分支
4. **限制清单**: 记录每个模块的已知限制和潜在改进点

### 数据流总览

```
INPUT 参数
  ├── hubbard_u (U 值)
  ├── orbital_corr (关联轨道: 2=d, 3=f)
  ├── omc (占据矩阵控制)
  └── uramping (U-ramping 步长)
       │
       ▼
  Plus_U::init()
  ├── 分配 locale[iat][l][n][spin]
  ├── 读取 omc 文件（如果启用）
  └── 初始化 U-ramping 参数
       │
       ▼
  SCF 循环（每步）
  ├── cal_occup_m_k/gamma() → 更新 locale
  ├── mix_locale() → 混合新旧占据矩阵
  ├── cal_eff_pot_mat() → 计算 V_eff
  ├── cal_energy_correction() → 计算 E_U
  └── U-ramping: U += uramping（如果未达目标）
       │
       ▼
  SCF 收敛后
  ├── force_stress() → DFT+U 力/应力贡献
  └── write_occup_m() → 输出占据矩阵
```

### f 电子 (l=3) 关键路径

审计需特别关注以下 f 电子特有路径：

| 文件 | 函数/位置 | f 电子相关逻辑 |
|------|-----------|---------------|
| `dftu.h` | `orbital_corr[]` | l=3 时矩阵维度为 7×7（2l+1=7） |
| `dftu.cpp` | `init()` | locale 分配大小依赖 `2*orbital_corr[]+1` |
| `dftu_occup.cpp` | `cal_occup_m_k()` | 内层循环 m=-l..l，l=3 时 m=-3..3 |
| `dftu_hamilt.cpp` | `cal_eff_pot_mat_*()` | 7×7 有效势矩阵（vs d 电子的 5×5） |
| `dftu_yukawa.cpp` | `cal_slater_UJ()` | Slater 积分 F^k，f 电子需要 k=0,2,4,6 |
| `dftu_tools.cpp` | CG/Gaunt 系数 | l=3 的 Gaunt 系数表更大 |
| `dftu_pw.cpp` | `cal_occ_pw()` | PW 基组下 f 电子投影可能精度不足 |

### 已知限制（审计重点）

- **PW 基组**: `dftu_pw.cpp` 的 f 电子支持不完善，投影精度依赖截断能
- **nspin 处理**: 部分函数对 nspin=4（SOC）的支持可能不完整
- **U-ramping**: 当前实现为线性增长，对 f 电子可能需要更保守的策略
- **Yukawa 自动 U**: `cal_slater_UJ()` 中 f 电子的 Slater 积分 F^6 项需要验证
- **内存**: l=3 的 locale 为 7×7 矩阵，比 l=2 的 5×5 大 96%，大体系可能有内存压力

### Critical Implementation Details

- **审计文档格式**: 每个源文件一个章节，包含函数列表、输入/输出/副作用、f 电子路径标注
- **数据流图**: 使用 Mermaid 或 ASCII 图表示模块间数据流
- **代码标注**: 对关键代码段添加行号引用，便于后续开发者定位
- **与 QE/VASP 对比**: 记录 ABACUS DFT+U 实现与 QE `v_hubbard.f90` 和 VASP `LDAU` 的差异

## TDD Test Plan

### Tests to Write FIRST

```python
# test_audit_completeness.py
import pytest
import os

AUDIT_PATH = "projects/f-electron-scf/audit/dftu_audit.md"

def test_audit_document_exists():
    """审计文档存在"""
    assert os.path.exists(AUDIT_PATH)

def test_audit_covers_all_source_files():
    """审计文档应覆盖所有 DFT+U 源文件"""
    with open(AUDIT_PATH) as f:
        content = f.read()
    required_files = [
        "dftu.h", "dftu.cpp", "dftu_occup.cpp", "dftu_hamilt.cpp",
        "dftu_yukawa.cpp", "dftu_pw.cpp", "dftu_io.cpp",
        "dftu_force.cpp", "dftu_tools.cpp"
    ]
    for fname in required_files:
        assert fname in content, f"Audit missing coverage of {fname}"

def test_audit_covers_f_electron_paths():
    """审计文档应标注 f 电子特有路径"""
    with open(AUDIT_PATH) as f:
        content = f.read()
    f_indicators = ["l=3", "orbital_corr", "f电子", "f_electron", "7×7", "7x7"]
    found = any(ind in content for ind in f_indicators)
    assert found, "Audit missing f-electron specific path analysis"

def test_audit_has_data_flow():
    """审计文档应包含数据流描述"""
    with open(AUDIT_PATH) as f:
        content = f.read()
    flow_indicators = ["数据流", "data flow", "init()", "SCF", "locale"]
    found_count = sum(1 for ind in flow_indicators if ind in content)
    assert found_count >= 3, "Audit missing data flow documentation"

def test_audit_has_limitations():
    """审计文档应包含已知限制清单"""
    with open(AUDIT_PATH) as f:
        content = f.read()
    assert "限制" in content or "limitation" in content.lower()
```

## Acceptance Criteria

- [ ] 完整的代码审计文档，包含数据流图
- [ ] f电子处理路径分析
- [ ] 已知限制和改进点清单
