# FE-205-1: ChargeConstraint 模块骨架与输入参数

## Objective

[工程追赶] 创建 charge_constraint.h/cpp 模块骨架：
(1) ChargeConstraint 类定义，包含 per-atom 约束参数结构体 (atom_index, n_target, lambda, orbital_l)
(2) INPUT 参数扩展：chg_constraint (bool), chg_constraint_atoms (string), chg_constraint_targets (double[]), chg_constraint_lambda0 (double)
(3) 从 INPUT 解析约束配置并初始化 ChargeConstraint 实例
(4) 单元测试验证参数解析正确性

## Reference Code

### Target Code (develop 分支)

**`/root/abacus-develop/source/source_lcao/module_dftu/dftu.h`** (354 lines)
- `Plus_U` 类 — 参考其类设计模式（静态成员、init 方法）
- `orbital_corr` — 每个原子类型的轨道角动量，用于确定约束哪个 l 通道

**`/root/abacus-develop/source/source_lcao/module_deltaspin/spin_constrain.h`** (291 lines)
- `SpinConstrain<TK>` — 参考其单例模式和 per-atom 约束数据结构
- `ScAtomData` — per-atom 约束参数结构体

**ABACUS INPUT 参数系统**:
- `source/source_io/input_parameter.h` — 输入参数定义
- `source/source_io/read_input.cpp` — 输入参数解析

### Prior Art

**DeltaSpin 的 per-atom 约束**: `SpinConstrain` 的 `ScAtomData` 结构体是很好的参考。
**DFT+U 的 omc**: `Plus_U::omc` 控制占据矩阵，constrained DFT 与之协同。

## Implementation Guide

### Architecture Decisions

- **新目录**: `source/source_lcao/module_constraint/`
- **类设计**: `ChargeConstraint` 非单例，由 ESolver 持有
- **per-atom 约束**: 使用结构体数组，每个元素包含原子索引、目标电子数、λ 值、轨道 l

### 类设计

```cpp
// charge_constraint.h
namespace constraint {

struct AtomConstraint {
    int atom_index;      // 原子索引
    int orbital_l;       // 约束的轨道角动量 (3 for f)
    double n_target;     // 目标电子数
    double lambda;       // 当前约束强度
    double lambda0;      // 初始约束强度
};

class ChargeConstraint {
public:
    void init(const std::vector<AtomConstraint>& constraints);
    void update(int scf_step);  // 更新 λ
    double get_penalty_energy() const;
    double get_penalty_potential(int iat) const;  // dV/dn
    bool is_converged(double tol = 0.05) const;

    // 从 INPUT 解析
    static ChargeConstraint from_input(const Input_para& inp, const UnitCell& ucell);

private:
    std::vector<AtomConstraint> constraints_;
    std::string decay_mode_ = "exp";  // "exp" or "linear"
    double tau_ = 50.0;               // 衰减时间常数
};

}  // namespace constraint
```

### INPUT 参数

| 参数 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `chg_constraint` | bool | false | 启用电荷约束 |
| `chg_constraint_atoms` | string | "" | 约束原子列表，如 "1 3 5" |
| `chg_constraint_targets` | string | "" | 目标电子数，如 "1.0 7.0 0.0" |
| `chg_constraint_lambda0` | double | 10.0 | 初始约束强度 (eV) |
| `chg_constraint_tau` | double | 50.0 | 衰减时间常数 |
| `chg_constraint_mode` | string | "exp" | 衰减模式: "exp" 或 "linear" |

### Critical Implementation Details

- **原子索引**: 从 1 开始（用户输入），内部转为 0-based
- **orbital_l 自动检测**: 从 `Plus_U::orbital_corr` 获取，如果原子有 f 轨道则 l=3
- **与 DFT+U 的依赖**: ChargeConstraint 需要 DFT+U 启用（因为需要 onsite projector）
- **错误检查**: 如果指定的原子没有 f 轨道，报错退出

## TDD Test Plan

### Tests to Write FIRST

```cpp
TEST_F(ChargeConstraintTest, ParseInput) {
    Input_para inp;
    inp.chg_constraint = true;
    inp.chg_constraint_atoms = "1 3";
    inp.chg_constraint_targets = "1.0 7.0";
    inp.chg_constraint_lambda0 = 10.0;

    auto cc = ChargeConstraint::from_input(inp, ucell);
    EXPECT_EQ(cc.num_constraints(), 2);
    EXPECT_EQ(cc.get_constraint(0).atom_index, 0);  // 0-based
    EXPECT_NEAR(cc.get_constraint(0).n_target, 1.0, 1e-10);
    EXPECT_NEAR(cc.get_constraint(0).lambda, 10.0, 1e-10);
}

TEST_F(ChargeConstraintTest, DisabledByDefault) {
    Input_para inp;  // chg_constraint = false
    auto cc = ChargeConstraint::from_input(inp, ucell);
    EXPECT_EQ(cc.num_constraints(), 0);
}

TEST_F(ChargeConstraintTest, ErrorOnNoFOrbital) {
    Input_para inp;
    inp.chg_constraint = true;
    inp.chg_constraint_atoms = "1";  // Si 没有 f 轨道
    EXPECT_THROW(ChargeConstraint::from_input(inp, si_ucell), std::runtime_error);
}
```

## Acceptance Criteria

- [ ] charge_constraint.h/cpp 编译通过
- [ ] INPUT 参数可正确解析约束配置
- [ ] 单元测试覆盖参数解析
- [ ] 错误检查完整（无 f 轨道、参数不匹配等）
